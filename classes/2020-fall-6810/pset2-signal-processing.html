<!DOCTYPE html>
<html>
<head>
	<title>HCI Engineering Group</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

	<!-- CSAIL ICON -->
	<link rel="CSAIL" href="../../images/icon/csail.ico" type="image/x-icon" />

	<!-- Bootstrap -->
	<link href="../../css/bootstrap.css" rel="stylesheet">
	<link href="../../css/custom-style.css" rel="stylesheet">

	<!-- jQuery -->
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

	<!-- Google Fonts -->
	<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Abel" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Barlow" rel="stylesheet">

	<!-- Google Analytic -->
	<script type="text/javascript" src="../../js/analytics.js"></script>

	<style>
	.etech-sch-col1 {width:60px; border: 1px solid black;padding:10px;}
	.etech-sch-col2 {width:120px; border: 1px solid black;padding:10px;}
	.etech-sch-col3 {width:450px; border: 1px solid black;padding:10px;}
	.etech-sch-col4 {width:70px; border: 1px solid black;padding:10px;}
  .etech-sch-col5 {width:70px; border: 1px solid black;padding:10px;}
  /*.etech-sch-col6 {width:170px; border: 1px solid black;padding:10px;}*/
  ul {
    padding:0px;padding-left:10px;margin:0px;
  }
	</style>
</head>

<body>
<header class="main_header">
	<!-- to be filled by javascript, see header.html -->
</header>

<section class="main_container">
	<div class="container">
    <div class="row nothing">

      <section class="col-md-8 pull-right main-content">
</br></br></br></br>
        <h4 class="medium.headline"><a href="6810-engineering-interactive-technologies.html">6.810 Engineering Interactive Technologies (fall 2020)</a><br></h>
        <h2 class="headline">Problem Set Series: Multi-Touch Pad</h2>


<img src="images/pset-overall2.png" width="600px">

          <hr>


<h2 class="headline">Problem Set 2</h2>

Now that you have the hardware ready, you will write some code for the sensing part of your multi-touch pad. In particular, you are going to do the following four steps:

<ul>
	<li>(1) Generate the appropriate PWM signal for the sender pin that is connected to the Multiplexer </li>
	<li>(2) Configure the Multiplexer to select the right output channel for sending the signal to the appropriate column of your multi-touch pad </li>
	<li>(3) Set up the ADC pins with the MCP3008 chip and SPI </li>
<!-- 	<li>(1) Identify the GPIO pin configurations and assign corresponding PinMode</li>
	<li>(2) Generate appropriate PWM signal and assign to sender pins</li> -->
	<li>(4) Read and record analog signals from receiver pins in Serial channel</li>
	<!-- <li>(4) Add the "button" mode and record the data in Serial channel</li> -->
</ul>
<br>

<h3>(1) Generate appropriate PWM signal </h3>

Below, you see the circuit schematic from pset1 again.<br>
The marked area is the sending circuit.<br>
You already build this on your breadboard, now we will code up the "Sending" part of the circuit! <br>br>

<img src="images/pset1/multitouch-schematic-sending.png" width="600px"> <br><br>
<br><br>

<h4>Programming the PWM Signal</h4>

We will start by generating the PWM signal for the circuit. <br>
You can download the skeleton code for the PSet2 from <a href="software/pset-skeleton_Arduino.zip"> here</a>. <br><br>

<b>Why do we need a PWM Signal?</b><br>

For our multi-touch pad to work, we need a signal that looks like a sine wave.<br>
However, the ESP by default is not able to do this. Instead the only thing that the ESP can generate, is a signal that is a square wave (e.g. by setting a pin to HIGH, then setting it to LOW subsequently).<br>

So how can we generate a square wave that approximates the sign wave that we need best?<br>
For this, we first need to know, what sign wave to we actually need!<br><br>

The sign wave we need is around 10MHz.<br>
The reason for this is that in this frequency range the finger can be considered a conductor that couples both electrodes. (We know that in the frequency ranges from 100 kHz to 40 MHz the electric field around the body behaves as a quasi-static near-field. <br>
We will have a TX electrode transmits a signal in the MHz range, and in this frequency range, the quasi-static electric field allows for strong capacitive coupling between the TX electrode, the finger, and the RX electrode.)<br><br>

So now the question is, how can we make a 10MHz signal based on square waves?<br>
So one square (pulse-width) actually consists of multiple overlapped sine wave signals of different frequencies. Those are generated with the microcontroller all at the same time with the microcontrollers internal clock, which works at 80 MHz. To generate different signals, the microcontroller has different internal timers that sample the signal at different rates (each time the clock creates a new signal we can change the internal state, so depending on how often the timer samples we get a different signal frequencies) and then overlaid over each other forming the square-signal. The good news is we don't have to do this ourselves, we just give the overall frequency of the square wave and the microcontroller will do all the timer business!<br>

We now know that the square wave is not a square wave but made from a bunch of different sine signals. So first we need to figure out which sine waves make up the square signal. The type of sine waves is determine by the length of the duty cycle (length of square) and the overall frequency.

So to have a square wave, we will have to turn on/off. We need to match 10MHz, so to have half on/off, we need a 50% duty cycle which would be 5MHz. 



The signal that we are generating for the TX electrodes is <b>4 MHz, 25% Duty Cycle</b>. <br><br>

Here’s the steps you’ll have to follow to set up the ESP32 PWM using the Arduino IDE: <br>
1. First, you need to choose a PWM channel. There are 16 channels from 0 to 15. <br>
2. Then, you need to set the PWM signal frequency, in our case 4 MHz. <br>
3. You also need to set the signal’s duty cycle resolution. you have resolutions from 1 to 16 bits. <br>
4. Next, you need to specify to which GPIO or GPIOs the signal will appear upon (don't forget to set the correct PinMode). <br>
5. Generate the PWM signal with a duty cycle value. <br><br>



The ESP32's default clock is 80 MHz.<br>
<!-- 
We know that in the frequency ranges from 100 kHz to 40 MHz the electric field around the body behaves as a quasi-static near-field. <br>
We will have a TX electrode transmits a signal in the MHz range, and in this frequency range, the quasi-static electric field allows for strong capacitive coupling between the TX electrode, the finger, and the RX electrode. <br>
Simply put, the finger can be considered a conductor that couples both electrodes. <br><br>

 -->


, and the duty resolution can be lowered down to 1 bit in which case the maximum frequency is 40 MHz, but only the duty of 50% is available. <br>


Pulse Width Modulation, or PWM, is a technique for getting analog results with digital means. <br>
Digital control is used to create a square wave, a signal switched between on and off. This on-off pattern can simulate voltages in between full on (3.3 Volts) and off (0 Volts) by changing the portion of the time the signal spends on versus the time that the signal spends off.<br><br>

<img src="images/pset2/pwm-explanation.png" width="450px"> <br><br>
<!-- 
We know that in the frequency ranges from 100 kHz to 40 MHz the electric field around the body behaves as a quasi-static near-field. <br>
We will have a TX electrode transmits a signal in the MHz range, and in this frequency range, the quasi-static electric field allows for strong capacitive coupling between the TX electrode, the finger, and the RX electrode. <br>
Simply put, the finger can be considered a conductor that couples both electrodes. <br><br> -->

For step 1-3, you can use the following function: <br>
<pre>ledcSetup(PWM_Channel_Number, Frequency, duty_resolution)</pre>

Notice that the frequency and duty resolution of the PWM signal has an inverse effect on each other. <br>
The ESP32's clock is 80 MHz, and the duty resolution can be lowered down to 1 bit in which case the maximum frequency is 40 MHz, but only the duty of 50% is available. <br>
The available duty levels are <b>(2^bit_num)-1</b>, where bit_num can be 1-15. <br>
The maximal frequency is <b>80000000 / 2^bit_num</b>. <br>
We will let you figure out the correct values for those parameters :) <br><br>

For step 4, you can use the following function: <br>
<pre>ledcAttachPin(GPIO_PIN , PWM_Channel_Number) </pre> <br>

For step 5, you can use the following function: <br>
<pre>ledcWrite(PWM_Channel_Number, DUTY_CYCLE): </pre> <br>

The code should be inside of the "<b>setupPWM()</b>" function in the skeleton code. <br>
<img src="images/pset2/setup-pwm.png" width="450px"> <br>

You can test if you have the correct signal via an oscilloscope. <br><br>

<h3>(2) Sending: Configure the Channel Selection for the Multiplexer</h3>

Next, we will write up the function that determines to which pin the multiplexer will send the signal as output. <br><br>

<b>Refresher from pset1</b><br>
Remember that the multiplexer in 'de-multiplex' mode takes the signal from one sender pin on the ESP and distributes it to the different sender columns on your multi-touch pad.<br>
Below is the image from pset1 again for your reference.<br><br>

<img src="images/pset1/mux-and-demux.jpg" width="500px"> <br><br>

Also remember that the S0 - S3 pins are used to create the address that determines which column pin (C0-C15) the input signal (SIG) should be send to. The image of the multiplexer from pset1 is shown below again for your reference. <br><br>

<img src="images/pset1/multiplexer-no-headers.png" width="150px"><br><br>  

To tell the multiplexer which pin the output signal should be send to, you need to create the desired output address using the four pins S0-S3. Why four pins? The multiplexer expects a binary signal, e.g. sending 0,0,0,0 to S0-S3 results in the output pin C0, vs. 0,1,1,0 sends the signal to C6.<br><br>

<b>Let's create the multiplexer addressing in code</b><br>

First, check which pins your multiplexer is wired to.<br>
In particular, you need the GPIO pin numbers for the multiplexer's S0 - S3 pins.<br>
Create the digital pins in your Arduino code and set the correct PinMode. <br><br>

Next, fill out the "<b>selectChannelOut(int channel)</b>" function in the skeleton code. <br>
<img src="images/pset2/select-channel-mux.png" width="450px"> <br>

The function takes an int for channel number and assigns the correct bit values to the 4 select pins (S0 - S3). <br>
Since our multi-touch pad is 8x9 electrodes, <span style="color:red">the channel numbers are either 0-7 or 0-8 depending on which dimension you chose for sending</span>.<br><br>

You can test if the function works properly by assigning specific output channel number and <span style="color:red">test the value on the select output channel to see if it is assigned with the signal. (what do you mean? on the hardware? in the terminal?)<br>
You can test that by an oscilloscope or a multimeter. </span> <br><br>

<h3>(3) Receiving: Set up the ADC pins with MCP3008 chip and SPI </h3>

Now that we have the sending all setup, you can move onto the "Receiving" part of the circuit.<br><br>

<b>Refresher from pset1</b><br>

Recall the circuit schematic from PSet1. <br>
In the schematic, all receiver rows (RX) are connected to analog-to-digital converter (ADC) pins. <br>
<img src="images/pset1/multitouch-schematic-receiving.png" width="600px"> <br><br>

In pset1, you already connected all your receiver rows to such pins, <span style="color:red">i.e. to either an analog-to-digital (ADC) converter pin or to a capacitive touch sensing pin (TOUCH) (which is also an ADC pin but provides a cleaner signal).</span><br><br>

<img src="images/esp32-pinout.jpg" width="500px"> <br><br>

<span style="color:red">(can you add why we need to analog to digital conversion? is this because of the PWM signal?)</span><br><br>

<b>Replacing the ADC pins</b><br>

Unfortunately, the ESP32 ADC/TOUCH pins are only reliable in the middle of the ESP's voltage range (~0.5V to maybe 3.0V) but not at the lower and upper ends of the range. Our touch sensing circuit functions <span style="color:red">at the lower range, i.e. mostly between XXV and YYV</span>. Even worse, because we use <span style="color:red">XXX to get YY working</span>, we end up with <span style="color:red">negative voltages on the ADC pins</span>, which are completely out of the spec of the ESP32's ADC inputs. <span style="color:red">(put back when clear how that relates to the rest: Since we are practically generating an AC signal with the PWM, plus the capacitive coupling effect between breadboard channels and wires under high frequency signal</span>). Under these circumstances, the signal will behave non-linearly and would require a lot of calibration. You could fix this by adding rectification circuits and amplifiers before having the signal go into the ADC pin, but that is quite some extra effort. For our purposes, it is therefore easier to not use the ESP ADC pins and instead use another ADC component that can work well within the Voltage range we use for the multi-touch pad.<br><br>

<b>Wiring up the new ADC Component</b><br>

The component you will use to have better ADC channels is the <a href="https://www.adafruit.com/product/856">MCP3008 </a> chip.
You can find the datasheet for MCP3008 <a href="https://cdn-shop.adafruit.com/datasheets/MCP3008.pdf">here</a>.<br><br>

<img src="images/pset2/adc-pin-chip.png" width="300px"><br><br>

, and communicate with ESP32 via SPI. <br>


The pinout of the MCP3008 chip and circuit schematic are shown down below: <br>
<img src="images/pset2/MCP3008-pinout.png" width="200px">
<img src="images/pset2/mcp3008-schematic.png" width="500px"> <br><br>

You will also find the following ESP32 pinout useful for identifying SPI pins: <br>
<img src="images/pset2/esp32-pinout.png" width="750px"> <br><br>

Once you have the circuit build up, you can download the MCP3008 library and construct & initialize it in the skeleton code. <br><br>
<img src="images/pset2/mcp3008-library.png" width="500px"> <br><br>

You can check if the ADC channels working properly on the MCP3008 by connecting a signal (e.g. 3.3V, random output pin on ESP32 set to HIGH etc.) to MCP3008 channels and see if the reading make sense. <br><br>

This is better in terms of scalability as well, since you can connect multiple ADC chips with SPI simultaneously, which allows us to arbirarily add more ADCs using a common SPI bus (so 4 pins gives 8 ADC channels and 5 pins gives 16 etc.).<br><br>


<h3>(4) Read and record analog signals from receiver pins in Serial channel </h3>
Now that you can fill the "<b>loop()</b>" function and do the actual sensing! <br>
<img src="images/pset2/loop-function.png" width="500px"> <br><br>

You should read through the receiver pins periodically like following:
<ul>
	<li>assign one output channel (sender pin) through the Multiplexer </li>
	<li>read through the receiver pins one by one through MCP3008 via SPI</li>
	<li>move on to the next output channel (sender pin) and repeat</li>
</ul> <br>

You should serial print the data in the following format: <br>
<pre>sender-channel-num0,receiver-ch0-val,receiver-ch1-val,receiver-ch2-val,...,receiver-ch7-val
sender-channel-num1,receiver-ch0-val,receiver-ch1-val,receiver-ch2-val,...,receiver-ch7-val
......</pre> <br>

A sample serial output could be: <br>
<pre>
0,3,2,1,3,4,5,2,4
1,4,3,5,1,3,7,5,2
...
</pre> <br>

If you open up the Serial Plotter, it should have something look like following when the multi-touch pad is not touched: <br>
<img src="images/pset2/multi-touch-pad-not-touch.png" width="350px"> <br><br>

And something look like these when touched & released (visually noticeable changes in raw value plot): <br>
<img src="images/pset2/multi-touch-pad-touch-1.png" width="350px">
<img src="images/pset2/multi-touch-pad-touch-2.png" width="350px">



<br>

<h3>Grading</h3>

We will give 25 pts in total:
<ul>
	<li>5 pts: you finished all for steps of the task.</li>
	<li>5 pts: PWM signal configuration and generates correctly.</li>
	<li>5 pts: output channel selection on Multiplexer working properly.</li>
	<li>5 pts: MCP3008 chip wired up and comminicates with ESP32 via SPI correctly.</li>
	<li>5 pts: receiver data read and record correctly.</li>
</ul>



        <br />
        <br />
      </section>

      <aside class="col-md-4 pull-left">
         <br /> <br /> <br /> <br />
<!-- 				 <h4>Pset Steps</h4><br>
				 <ul>
		 			<li><a href="#pset1">pset1 (due Sept. 21, 11.59pm): laser cut and bend the acrylic base</a><br /></li>
		 			<li><a href="#pset2">pset2 (due Oct. 5, 1pm): insert LEDs, add USB connecting and solder everything</a><br /></li>
		 			<li><a href="#pset3">pset3 (due Oct. 19, 1pm): write touch recognition so that you can determine (x,y) location of each finger</a><br /></li>
		 			<li><a href="#pset4">pset4 (due Oct. 26, 1pm): add an application of your choice</a><br /></li>
				</ul>
				<br /> <br /> <br /> <br />
        <img src="../2018-fall-6810/images/multi-touch-pad/iap1.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad/iap2.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad//iap3.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad/iap4.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad/iap5.jpg" width="220px">
 -->



        <!-- Publication -->

        <br><br><br><br><br>

        <!-- Publication -->

<!-- <h4>Side Bar</h4><br>

    <ul>
      <li>Prof. Stefanie Mueller (Instructor)</li>
      <li>Lotta-Gili Blumberg (TA)</li>
      <li>Xin Wen (UTA)</li>
      <li>Loren Maggiore (LA)</li>
      <li>Mark Chounlakone (LA)</li>
    </ul>
 -->
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>

      </aside>

    </div>
  </div>
  </div>
</section>

<div class="container">
	<div class="row">
		<div class="col-md-12 footer" style="text-align: center;">
			<span class="copyright">
			Since 2017 &copy; MIT CSAIL (HCI Engineering group) [redesign by
			<a href="http://punpongsanon.info/" target="_blank" style="text-decoration:none; border-bottom:0px">
			moji
			</a>].
			All Rights Reserved.

			<a href="http://mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/mit.svg" alt="MIT" class="footer-logo" />
			</a>
			<a href="http://csail.mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/csail.svg" alt="CSAIL" class="footer-logo"/>
			</a>
			<a href="http://hci.csail.mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/hci.svg" alt="HCI" class="footer-logo"/>
			</a>
			</span>
		</div>
	</div>
</div>

<!-- Bootstrap -->
<script type="text/javascript" src="../../js/bootstrap.min.js"></script>
<!-- header -->
<script type="text/javascript" src="../../js/headerstrap-for-subpage.js"></script>

</body>
</html>
