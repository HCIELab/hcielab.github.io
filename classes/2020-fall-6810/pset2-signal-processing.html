<!DOCTYPE html>
<html>
<head>
	<title>HCI Engineering Group</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

	<!-- CSAIL ICON -->
	<link rel="CSAIL" href="../../images/icon/csail.ico" type="image/x-icon" />

	<!-- Bootstrap -->
	<link href="../../css/bootstrap.css" rel="stylesheet">
	<link href="../../css/custom-style.css" rel="stylesheet">

	<!-- jQuery -->
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

	<!-- Google Fonts -->
	<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Abel" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Barlow" rel="stylesheet">

	<!-- Google Analytic -->
	<script type="text/javascript" src="../../js/analytics.js"></script>

	<style>
	.etech-sch-col1 {width:60px; border: 1px solid black;padding:10px;}
	.etech-sch-col2 {width:120px; border: 1px solid black;padding:10px;}
	.etech-sch-col3 {width:450px; border: 1px solid black;padding:10px;}
	.etech-sch-col4 {width:70px; border: 1px solid black;padding:10px;}
  .etech-sch-col5 {width:70px; border: 1px solid black;padding:10px;}
  /*.etech-sch-col6 {width:170px; border: 1px solid black;padding:10px;}*/
  ul {
    padding:0px;padding-left:10px;margin:0px;
  }
	</style>
</head>

<body>
<header class="main_header">
	<!-- to be filled by javascript, see header.html -->
</header>

<section class="main_container">
	<div class="container">
    <div class="row nothing">

      <section class="col-md-8 pull-right main-content">
</br></br></br></br>
        <h4 class="medium.headline"><a href="6810-engineering-interactive-technologies.html">6.810 Engineering Interactive Technologies (fall 2020)</a><br></h>
        <h2 class="headline">Problem Set Series: Multi-Touch Pad</h2>


<img src="images/pset-overall2.png" width="600px">

          <hr>


<h2 class="headline">Problem Set 2</h2>

Now that you have the hardware ready, you will write some code for the sensing part of your multi-touch pad. In particular, you are going to do the following four steps:

<ul>
	<li>(1) Generate the appropriate PWM signal for the sender pin. Send the PWM signal from the sender pin to the multiplexer.</li>
	<li>(2) Configure the Multiplexer to select the right output channel to forward the PWM signal to the appropriate column of your multi-touch pad.</li>
	<li>(3) For receiving, replace the ESP ADC pins with external ADC pins by wiring up the MCP3008 chip. Read data from the external ADC pins via Serial Peripheral Interface (SPI) communication.</li>
	<li>(4) Iterate over each column and row to read the signals and plot them on the serial plotter.</li>
	<!-- <li>(4) Add the "button" mode and record the data in Serial channel</li> -->
</ul>
<br>

<h3>Skeleton Code</h3>

Start by downloading <a href="software/pset-skeleton_Arduino.zip">the skeleton code for the PSet2 from  here</a>. <br><br>

<h3>(1) Generate the appropriate PWM signal for the sender pin </h3>

As you can see in the circuit schematic, the first thing we need to do in code is to generate a PWM signal from the sender pin. This PWM signal then goes into the multiplexer and so on.<br><br>

<img src="images/pset1/multitouch-schematic-sending.png" width="600px"> <br><br>

<b>Pulse Width Modulation</b>
Remember from lab3, that PWM is a technique for getting analog results with digital means. <br>
The digital control is used to create a signal that is switched between on and off. This on-off pattern can then simulate voltages in-between full on (in our case: 3.3 Volts) and completely off (0 Volts) by changing the portion of the time the signal spends on versus the time that the signal spends off.<br><br>

<img src="images/pset2/pwm-explanation.png" width="450px"> <br><br>

<b>Our PWM Signal: 4 MHz, 25% Duty Cycle</b><br>
The signal that we are generating for the sender pin is <b>4 MHz, 25% Duty Cycle</b>. <br>
We will spare you the details why exactly we need this PWM signal since this falls under more advanced electronics.<br><br>

To setup this PWM signal in code, start by downloading the skeleton code for the PSet2 from <a href="software/pset-skeleton_Arduino.zip"> here</a>. <br><br>

Here’s the steps you’ll have to follow to set up the ESP32 PWM using the Arduino IDE: <br>
1. First, you need to choose a PWM channel. There are 16 channels from 0 to 15. <br>
2. Then, you need to set the PWM signal frequency, in our case 4 MHz. <br>
3. You also need to set the signal’s duty cycle resolution. you have resolutions from 1 to 16 bits. <br>
4. Next, you need to specify to which GPIO or GPIOs the signal will appear upon (don't forget to set the correct PinMode). <br>
5. Generate the PWM signal with a duty cycle value. <br><br>


For step 1-3, you can use the following function: <br>
<pre>ledcSetup(PWM_Channel_Number, Frequency, duty_resolution)</pre>

Notice that the frequency and duty resolution of the PWM signal has an inverse effect on each other. <br>
The ESP32's clock is 80 MHz, and the duty resolution can be lowered down to 1 bit in which case the maximum frequency is 40 MHz, but only the duty of 50% is available. <br>
The available duty levels are <b>(2^bit_num)-1</b>, where bit_num can be 1-15. <br>
The maximal frequency is <b>80000000 / 2^bit_num</b>. <br>
We will let you figure out the correct values for those parameters :) <br><br>

For step 4, you can use the following function: <br>
<pre>ledcAttachPin(GPIO_PIN , PWM_Channel_Number) </pre> <br>

For step 5, you can use the following function: <br>
<pre>ledcWrite(PWM_Channel_Number, DUTY_CYCLE): </pre> <br>

The code should be inside of the "<b>setupPWM()</b>" function in the skeleton code. <br>
<img src="images/pset2/setup-pwm.png" width="450px"> <br>

You can test if you have the correct signal via an oscilloscope. <br><br>

<span style='color:red'>Setting SIG on multiplexer.</span><br><br>

<!-- 
<h4>Programming the PWM Signal</h4>

We will start by generating the PWM signal for the circuit. <br>
 -->

<!-- <b>Why do we need a PWM Signal?</b><br>

For our multi-touch pad to work, we need a signal that looks like a sine wave.<br>
However, the ESP by default is not able to do this. Instead the only thing that the ESP can generate, is a signal that is a square wave (e.g. by setting a pin to HIGH, then setting it to LOW subsequently).<br>

So how can we generate a square wave that approximates the sign wave that we need best?<br>
For this, we first need to know, what sign wave to we actually need!<br><br>

The sign wave we need is around 10MHz.<br>
The reason for this is that in this frequency range the finger can be considered a conductor that couples both electrodes. (We know that in the frequency ranges from 100 kHz to 40 MHz the electric field around the body behaves as a quasi-static near-field. <br>
We will have a TX electrode transmits a signal in the MHz range, and in this frequency range, the quasi-static electric field allows for strong capacitive coupling between the TX electrode, the finger, and the RX electrode.)<br><br>

So now the question is, how can we make a 10MHz signal based on square waves?<br>
So one square (pulse-width) actually consists of multiple overlapped sine wave signals of different frequencies. Those are generated with the microcontroller all at the same time with the microcontrollers internal clock, which works at 80 MHz. To generate different signals, the microcontroller has different internal timers that sample the signal at different rates (each time the clock creates a new signal we can change the internal state, so depending on how often the timer samples we get a different signal frequencies) and then overlaid over each other forming the square-signal. The good news is we don't have to do this ourselves, we just give the overall frequency of the square wave and the microcontroller will do all the timer business!<br>

We now know that the square wave is not a square wave but made from a bunch of different sine signals. So first we need to figure out which sine waves make up the square signal. The type of sine waves is determine by the length of the duty cycle (length of square) and the overall frequency.

So to have a square wave, we will have to turn on/off. We need to match 10MHz, so to have half on/off, we need a 50% duty cycle which would be 5MHz. 

 -->




The ESP32's default clock is 80 MHz.<br>
<!-- 
We know that in the frequency ranges from 100 kHz to 40 MHz the electric field around the body behaves as a quasi-static near-field. <br>
We will have a TX electrode transmits a signal in the MHz range, and in this frequency range, the quasi-static electric field allows for strong capacitive coupling between the TX electrode, the finger, and the RX electrode. <br>
Simply put, the finger can be considered a conductor that couples both electrodes. <br><br>

 -->


, and the duty resolution can be lowered down to 1 bit in which case the maximum frequency is 40 MHz, but only the duty of 50% is available. <br>


<!-- 
We know that in the frequency ranges from 100 kHz to 40 MHz the electric field around the body behaves as a quasi-static near-field. <br>
We will have a TX electrode transmits a signal in the MHz range, and in this frequency range, the quasi-static electric field allows for strong capacitive coupling between the TX electrode, the finger, and the RX electrode. <br>
Simply put, the finger can be considered a conductor that couples both electrodes. <br><br> -->



<h3>(2) Sending: Configure the Channel Selection for the Multiplexer</h3>

Next, we will write up the function that determines to which pin the multiplexer will send the signal as output. <br><br>

<b>Refresher from pset1</b><br>
Remember that the multiplexer in 'de-multiplex' mode takes the signal from one sender pin on the ESP and distributes it to the different sender columns on your multi-touch pad.<br>
Below is the image from pset1 again for your reference.<br><br>

<img src="images/pset1/mux-and-demux.jpg" width="500px"> <br><br>

Also remember that the S0 - S3 pins are used to create the address that determines which column pin (C0-C15) the input signal (SIG) should be send to. The image of the multiplexer from pset1 is shown below again for your reference. <br><br>

<img src="images/pset1/multiplexer-no-headers.png" width="150px"><br><br>  

To tell the multiplexer which pin the output signal should be send to, you need to create the desired output address using the four pins S0-S3. Why four pins? The multiplexer expects a binary signal, e.g. sending 0,0,0,0 to S0-S3 results in the output pin C0, vs. 0,1,1,0 sends the signal to C6.<br><br>

<b>Let's create the multiplexer addressing in code</b><br>

First, check which pins your multiplexer is wired to.<br>
In particular, you need the GPIO pin numbers for the multiplexer's S0 - S3 pins.<br>
Create the digital pins in your Arduino code and set the correct PinMode. <br><br>

Next, fill out the "<b>selectChannelOut(int channel)</b>" function in the skeleton code. <br>
<img src="images/pset2/select-channel-mux.png" width="450px"> <br>
<span style="color:red">rename mux to multiplexer in comments</span><br><br>

The function takes an int for channel number and assigns the correct bit values to the 4 select pins (S0 - S3). <br>
Since our multi-touch pad is 8x9 electrodes in size and 9 is the number of sender lines, the channel numbers are 0-8.<br>
Don't forget to use digitalWrite to write the correct value to each of the S0-S3 pins after you determined if they should be 0 or 1.<br><br>

You can test if your channel selection function works properly in the following way: First, choose an output pin for testing from the C0-C8 output pins and set it in your function. Next, use a multimeter to measure if the channel actually receives any voltage. Note that this is different than measuring resistance. Therefore, you need to set the multimeter into 'V' mode for measuring voltage, and then measure on the output pin and on GND. You should see 3.3V in the display. If you see 0, no voltage is applied and you need to further debug your code to figure out why the pin is not receiving the signal.<br><br>

<img src="images/pset2/multimeter-v.png" width="250px"> <br><br>

Note that in the code, there is a delay function. You may need to adjust the delay slightly depending on the amoung of capacitive coupling your specific design has. <span style="color:red">(Junyi if you can explain this a bit more detailed what that is and why that'd be great.)</span><br><br>


<h3>(3) Receiving: External ADC pins and SPI Communication</h3>

Now that we have the sending all setup, you can move onto the "Receiving" part of the circuit.<br><br>

<b>Refresher from pset1</b><br>

Recall the circuit schematic from pset1. <br>
In the schematic, all receiver rows (RX) are connected to analog-to-digital converter (ADC) pins. <br>
<img src="images/pset1/multitouch-schematic-receiving.png" width="600px"> <br><br>

In pset1, you already connected all your receiver rows to such pins, i.e. to either an analog-to-digital (ADC) converter pin or to a capacitive touch sensing pin (TOUCH), which is also an ADC pin but provides a cleaner signal as you can see in the pinout below.<br><br>

<img src="images/esp32-pinout.jpg" width="500px"> <br><br>

<b>Replacing the ADC pins</b><br>

Unfortunately, the ESP32 ADC/TOUCH pins are only reliable in the middle of the ESP's voltage range (~0.5V to maybe 3.0V) but not at the lower and upper ends of the range. Our touch sensing circuit functions at the lower range <span style="color:red">(why? because we turn it on and off quickly with the PWM so we end up with something between 0-3.3V?</span>. Even worse, because our circuit operates between -0.6V and 1.2V (yes that is a minus), we end up with negative voltages on the ADC pins, which are completely out of the spec of the ESP32's ADC inputs and would create a signal that is non-linear and would require a lot of calibration. The reason we can have negative voltages is because we are practically generating a high-frequency AC signal with the PWM. This creates capacitive coupling between the breadboard channels and wires. To make the ESP ADC pins work with negative voltages, you could add rectification circuits and amplifiers before having the signal go into the ADC pin, but that is quite some extra effort. For our purposes, it is therefore easier to not use the ESP ADC pins and instead use another ADC component that can work well within the Voltage range we use for the multi-touch pad.<br><br>

The component you will use to have better ADC channels is the <a href="https://www.adafruit.com/product/856">MCP3008 </a> chip.<br>
You can find the datasheet for MCP3008 <a href="https://cdn-shop.adafruit.com/datasheets/MCP3008.pdf">here</a>.<br>
Before you can wire it up, you need to first learn a bit more about the Serial Peripheral Interface, with which the chip communicates with the ESP.<br><br>

<img src="images/pset2/adc-pin-chip.png" width="300px"><br><br>

<b>Serial Peripheral Interface Communication between ESP and MPC Chip</b><br>

The MCP chip communicates with the ESP32 via the Serial Peripheral Interface (SPI).<br>
The basic SPI communication is between one master and one slave and we will use this for this pset since we only have one MPC chip (slave) connected to one master (ESP). But one master can also send to multiple slaves.<br><br>

<img src="images/pset2/spi-mosi-miso.png" width="300px"><br><br>

Broken down, the SPI interface consists of the following pins:<br>
<b>MOSI:</b> line for the master to send data to the slave.<br>
<b>MISO:</b> line for the slave to send data to the master.<br>
<b>SCK:</b> line for the clock signal (this determines how fast bits of data can be send, one bit of data is transferred during each clock cycle).<br>
<b>NSS/CS:</b> line for the master to select which slave to send the data to. <br>

So how does this look like on our MPC3008 chip?<br>
The pinout of the MCP3008 chip is shown below. <br> <br>

<img src="images/pset2/MCP3008-pinout.png" width="200px"><br><br>

Input and Power Pins:<br>
<b>CH0-7:</b> are the inputs from your multi-touch pad. You can have up to 8 inputs (CH0-CH7).<br>
<b>Vdd:</b> is connected to the 3.3V of the ESP to power the MPC chip.<br>
<b>Dgnd:</b> is connected to GND on the ESP to power the MPC chip.<br><br>

Pins for the SPI interface:<br>
<b>DIn</b> = MOSI, line for master to send data to slave</br>
<b>DOut</b> = MISO, line for slave to send data to master</br>
<b>CLK</b> = SCK, line for clock signal </br>
<b>CS/SHDN</b> = NSS/CS, line for master to select which slave to talk to</br><br>

Reference Signal:<br>
In addition to the communication lines, the SPI communication also needs a reference signal to determine <span style="color:red">(Junyi, remind me what is this good for?)</span>. It can, for instance, be set to 3.3V and to 5V. In our case, we want to set it to 3.3V <span style="color:red">because XX</span>.<br>
<b>VRef:</b> connect to 3.3V for generating the reference signal<br>
<b>AGND:</b> connect to GND<br><br>

To figure out how to connect the MOSI, MISO, SCK, NSS pins to the ESP32, you can refer to the pin out below.<br>
Make sure you are not accidentally using the VSPI or I2C communication pins.<br>
Remember that the NSS pin is used to select which slave to talk to, so this is a regular GPIO pin for sending a pin number.<br><br>

<img src="images/pset2/esp32-pinout.png" width="750px"> <br><br>

<b>Install MCP3008 Library and Write Code</b><br>

Once you have the circuit build up, download the MCP3008 library.<br>
To install it it, go to Sketch -> Include Library -> Manage Libraries and search for the MCP3008 library, then install it.<br>
To be on the safe side, restart your Arduino IDE.<br><br>

<img src="images/pset2/mcp3008-library.png" width="700px"> <br><br>

Go to File -> Examples and look at the bottom where it says 'Examples from Custom Libraries' to find example code that shows how to use the MCP3008 library. We recommend you look at the 'simpletest' example.<br><br>

<img src="images/pset2/mpc-library-examples.png" width="400px"> <br><br>

As you can see in the simpletest example, you need to first include the library on top in the skeleton code.<br>
After this, you need to declare an object of the library.<br>
Next, you need to open the communication channel with begin() in the setup function.<br>
Once the channel is open, you can read a the signal from one of the input channels CH0-CH7 using the readADC(channelnumber) function.<br>
If you serial print the result, you should see your analog signal coming through as if you had connected the channel input directly to the ESP.<br>
Note that you do not have to specify which pins the ESP should be using for the SPI communication since it already knows this from its own pinout, which only has one pin per SPI MISO line.<br><br>

<span style="color:red">do I not need to set the GPIO pin for the slave number?</span><br>
<span style="color:red">do we even need the MOSI line? if yes, for what?</span><br>
<span style="color:red">do we even need the CLK line? if yes, where is this set?</span><br><br>

<b>Testing your Code</b><br>

You can check if the SPI communication with the ADC channels works properly by doing the following:<br>
Connect a 3.3V output pin from the ESP to one of the MCP3008 CH input channels and plot the result on the Serial Plotter.<br>
You should see a signal there around 1000. If you see 0 nothing is coming through and it needs further debugging.<br><br>


<h3>(4) Receiving: Read and record analog signals from receiver pins in Serial channel</h3>

Now that we have our new ADC pins setup and are getting a better signal, we can start reading the signal and determine the result of the user interaction with the multi-touch pad, i.e. where the user touched.<br><br>

In particular, we will fill the "<b>loop()</b>" function with more lines. <br><br>
<img src="images/pset2/loop-function.png" width="500px"> <br><br>

Remember, that we want to first send a signal through one column, then read each row of the multi-touch pad one after another, and then continue to the next column. <br><br>

You can do this in code in the following way:<br>
<ul>
	<li>first, send a signal to the output channel of the Multiplexer that corresponds to the first column of your multi-touch pad</li>
	<li>next, read through the receiver pins one by one through the MCP3008 chip via SPI</li>
	<li>next, move on to the output channel that corresponds to the next column of your multi-touch pad and repeat</li>
</ul> <br>

Serial print the data in the format: columm0, row0val, row1val, row2val...<br>
A sample serial output could be: <br>
<pre>
0,3,2,1,3,4,5,2,4 //column0, row0val, row1val, row2val...
1,4,3,5,1,3,7,5,2 //column1, row0val, row1val, row2val...
...
</pre> <br>
<span style="color:red">are these real outputs? these look fake except for the column number?</span><br><br>

<!-- <pre>sender-channel-num0,receiver-ch0-val,receiver-ch1-val,receiver-ch2-val,...,receiver-ch7-val
sender-channel-num1,receiver-ch0-val,receiver-ch1-val,receiver-ch2-val,...,receiver-ch7-val
......</pre> <br>
 -->
<!-- <pre>sender-channel-num0,receiver-ch0-val,receiver-ch1-val,receiver-ch2-val,...,receiver-ch7-val
sender-channel-num1,receiver-ch0-val,receiver-ch1-val,receiver-ch2-val,...,receiver-ch7-val
......</pre> <br>
 -->


If you open up the Serial Plotter, it should have something look like following when the multi-touch pad is not touched, i.e. all values are roughly the same height. <br>
<img src="images/pset2/multi-touch-pad-not-touch.png" width="350px"> <br><br>

It should look like this when touched and released, i.e. there is a spike in the raw value plot. <br>
<img src="images/pset2/multi-touch-pad-touch-1.png" width="350px">
<img src="images/pset2/multi-touch-pad-touch-2.png" width="350px"><br><br>

If you see it like this, you are done.<br>
We will do the visualization and further processing of the touch signal in pset3.<br><br>


<h3>Grading</h3>

We will give 25 pts in total:
<ul>
	<li>5 pts: does your code configure and generate the PWM signal correctly?</li>
	<li>5 pts: does your code correctly select the channel on the multiplexer to address the correct column?</li>
	<li>5 pts: is the MCP3008 chip correctly wired up?</li>
	<li>5 pts: does the ESP communicate with the MCP chip correctly via SPI?</li>
	<li>5 pts: is the receiver data read and recorded correctly?</li>
</ul>



        <br />
        <br />
      </section>

      <aside class="col-md-4 pull-left">
         <br /> <br /> <br /> <br />
<!-- 				 <h4>Pset Steps</h4><br>
				 <ul>
		 			<li><a href="#pset1">pset1 (due Sept. 21, 11.59pm): laser cut and bend the acrylic base</a><br /></li>
		 			<li><a href="#pset2">pset2 (due Oct. 5, 1pm): insert LEDs, add USB connecting and solder everything</a><br /></li>
		 			<li><a href="#pset3">pset3 (due Oct. 19, 1pm): write touch recognition so that you can determine (x,y) location of each finger</a><br /></li>
		 			<li><a href="#pset4">pset4 (due Oct. 26, 1pm): add an application of your choice</a><br /></li>
				</ul>
				<br /> <br /> <br /> <br />
        <img src="../2018-fall-6810/images/multi-touch-pad/iap1.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad/iap2.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad//iap3.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad/iap4.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad/iap5.jpg" width="220px">
 -->



        <!-- Publication -->

        <br><br><br><br><br>

        <!-- Publication -->

<!-- <h4>Side Bar</h4><br>

    <ul>
      <li>Prof. Stefanie Mueller (Instructor)</li>
      <li>Lotta-Gili Blumberg (TA)</li>
      <li>Xin Wen (UTA)</li>
      <li>Loren Maggiore (LA)</li>
      <li>Mark Chounlakone (LA)</li>
    </ul>
 -->
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>

      </aside>

    </div>
  </div>
  </div>
</section>

<div class="container">
	<div class="row">
		<div class="col-md-12 footer" style="text-align: center;">
			<span class="copyright">
			Since 2017 &copy; MIT CSAIL (HCI Engineering group) [redesign by
			<a href="http://punpongsanon.info/" target="_blank" style="text-decoration:none; border-bottom:0px">
			moji
			</a>].
			All Rights Reserved.

			<a href="http://mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/mit.svg" alt="MIT" class="footer-logo" />
			</a>
			<a href="http://csail.mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/csail.svg" alt="CSAIL" class="footer-logo"/>
			</a>
			<a href="http://hci.csail.mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/hci.svg" alt="HCI" class="footer-logo"/>
			</a>
			</span>
		</div>
	</div>
</div>

<!-- Bootstrap -->
<script type="text/javascript" src="../../js/bootstrap.min.js"></script>
<!-- header -->
<script type="text/javascript" src="../../js/headerstrap-for-subpage.js"></script>

</body>
</html>
