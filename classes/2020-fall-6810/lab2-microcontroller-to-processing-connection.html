<!DOCTYPE html>
<html>
<head>
	<title>HCI Engineering Group</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

	<!-- CSAIL ICON -->
	<link rel="CSAIL" href="../../../images/icon/csail.ico" type="image/x-icon" />

	<!-- Bootstrap -->
	<link href="../../css/bootstrap.css" rel="stylesheet">
	<link href="../../css/custom-style.css" rel="stylesheet">

	<!-- jQuery -->
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

	<!-- Google Fonts -->
	<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Abel" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Barlow" rel="stylesheet">

	<!-- Google Analytic -->
	<script type="text/javascript" src="../../js/analytics.js"></script>

	<style>
	.etech-sch-col1 {width:60px; border: 1px solid black;padding:10px;}
	.etech-sch-col2 {width:120px; border: 1px solid black;padding:10px;}
	.etech-sch-col3 {width:450px; border: 1px solid black;padding:10px;}
	.etech-sch-col4 {width:70px; border: 1px solid black;padding:10px;}
  .etech-sch-col5 {width:70px; border: 1px solid black;padding:10px;}
  /*.etech-sch-col6 {width:170px; border: 1px solid black;padding:10px;}*/
  ul {
    padding:0px;padding-left:10px;margin:0px;
  }
	</style>
</head>

<body>
<header class="main_header">
	<!-- to be filled by javascript, see header.html -->
</header>

<section class="main_container">
	<div class="container">
    <div class="row nothing">

      <section class="col-md-8 pull-right main-content">
</br></br></br></br>
        <h4 class="medium.headline"><a href="6810-engineering-interactive-technologies.html">6.810 Engineering Interactive Technologies (fall 2020)</a><br></h>
        <h2 class="headline">Part 2: Connecting Micro-controller to UI</h2>
      
          <hr>

          <!-- Code in: Documents / Processing / SimpleRead --> 
          <!-- Code in: Documents / Arduino / serial-write -->
          <!-- Code in: Documents / Processing / SimpleWrite -->
          <!-- Code in: Documents / Arduino / serial-read -->

<h2 class="headline">Your Task for Today</h2>

In the last lab, we have already done steps 1-4 to get our interactive music card going.<br><br>

<b>(last lab) (1) Circuit Design:</b> You will first draw the circuit design of your card by creating a 2D drawing of the wires and interactive touch and slider areas.<br>
<b>(last lab) (2) Conductive Silver Inkjet Printing:</b> Next, you will print your design with conductive inkjet printing.<br>
<b>(last lab) (3) Wiring up the Buttons:</b> In the next step, you will wire up your touch buttons using a breadboard and an ESP32 microcontroller.<br>
<b>(last lab) (4) Sensing the Touch Signals:</b> Next, you will sense the touch signals using capacitive touch sensing (through Arduino's CapacitiveSensor Library) and apply filtering to the signals.<br><br>

Today, we are going to connect your card to Processing: When you push the physical touch button it will light up the corresponding digital touch button in Processing and the associated song will play. We will also extend the circuit and signal processing to include the touch slider for the music volume, which we haven't wired up yet.<br><br>

<b>(today) (5) Visualizing User Input:</b> Next, you will setup the touch buttons <!-- and sliders --> in a programming environment called Processing, which will visualize when physical input on the touch buttons <!-- and sliders --> on screen and also play the corresponding songs. <br>
<b>(today) (6) Wiring up and Visualizing the Slider:</b> Finally, you will add the slider to your circuit and user interface and use it to control the music volume.<br><br>

<h4>Make sure everything from last lab is still working</h4><br>

Before getting started with the new content, let's first make sure everything from last time is still working and no wires came lose.<br> 
To do this, connect your music card and ESP32 again to your computer via USB and upload the program that you haven written in the last lab.<br> 
Double check that everything is still working, i.e. when touching one of the touch buttons you should see the touch signals show on the Serial monitor.<br><br>

 <h3 class="headline">(5) Visualizing User Input with Processing</h3><br>


<h4>Receiving Touch Input in Processing:<br> Create Processing Script that Listens to Serial Communication</h4><br>

In the last lab, we sent the touch input to the Arduino IDE and plotted it in the Serial Monitor or Serial Plotter.<br>
Since Arduino has no libraries for graphical user interfaces, we now want to instead send our touch input to Processing.<br>
<br>

<a href="https://processing.org" target="_blank">Processing</a> is a user interface protoyping platform that is based on Java. It was created by MIT students (and others) in their spare time starting in Spring 2001 and is nowadays used by thousands of makers and UI designers. You can find useful information on how to use it in their <a href="https://processing.org/tutorials/" target="_blank">tutorial section</a>.<br><br>

In the last lab, we encoded a touch event in the format:<br><br>

<code>(sensor ID),(is_touched)(newline)</code><br><br>
    
(sensor ID) is either 0, 1 or 2 and represents the ID of the observed touch sensor.<br>
(is_touched) is either 0 or 1 (0 if the sensor is not touched, and 1 if it is touched).<br><br>

And wrote it to the Serial port using <code>Serial.print()</code>.<br><br>

In order to use this information in Processing, we need to write a Processing script that listens to the Serial communication.<br><br>

To do this, open Processing, create a new program, and import the <a href="https://processing.org/reference/libraries/serial/index.html">Serial library</a>.<br>
<pre>import processing.serial.*;</pre><br>

Next, you need to create a new port that can be used for communication by creating an object from this class: <br>
<pre>Serial myPort;</pre><br>

To create the port, you need to define three things: (1) you need to tell the port which application will listen to it (i.e. 'this' one), (2) you need to tell the port its portname, and (3) you need to tell the port at which baudrate it should listen to be able to decode the messages. <br><br>

<pre>myPort = new Serial(this, portName, baudrate);</pre><br>
    
For the <code>portName,</code> you can get a list of all available ports from the Serial library (see below).<br> 
By accessing different buckets of the list, you can get access to the name of each port.<br>
The correct port is the one you also used in your Arduino program, i.e. this is where the microcontroller is connected to your laptop.<br>
Check if the correct portname is in bucket 0, 1, or 2 by printing it.<br><br>

<pre>// check which port you use: 0, 1, 2?
String portName = Serial.list()[2];
print(portName);</pre><br>

For the <code>baudrate</code>, you also already know this from your Arduino program that you uploaded to the microcontroller.<br>
Check in your Arduino program with which baudrate you initialized the Serial communication.<br>
If you use a different baudrate than you wrote into the Arduino program, you will only get a lot of random stuff back since your Processing application will not know how to 'translate' the messages that are coming from the microcontroller since it would 'speak' at a different frequency than the Processing application would 'listen'.<br><br>

Now that your port is defined, we are ready to listen to it and check if data is available, but before we do this let's briefly look at the Processing program structure.<br><br>

<h4>Processing Program Structure: setup() and draw() functions</h4><br>

Similar to Arduino, every Processing program has two functions: one that is run only once (setup()) and one that is looping forever (draw()).<br><br>

Before we move to the next step, let's create a setup function:<br><br>

<pre>
void setup() { // runs only once
  
}
</pre><br>

Move all your code for defining the port into the setup() funtion since we only need to define the port once.<br><br>

Next, create an empty draw function:<br>

<pre>
void draw() { //runs infinitely
  
}
</pre><br>

We are going to fill this in the next step with the code that will continously listen to the port and see if any new messages are there from the microcontroller.<br><br>

<h4>Reading Data from the Serial Port</h4><br>

Now that we have the port defined, we can see if data is available.<br>
In the draw function, you need to first check if there is data on the port available, and then you can read the value from the port.<br><br>

<pre>int val;

// If there is a message with at least 4 characters 
// remember we are sending in the format: <i>sensorNumber comma touched semicolon</i> with one character each
if (myPort.available() >= 4) { 

    // read a String until the character ';' is found, which indicates the end of our message
    String val = myPort.readStringUntil(';'); 
  }</pre><br>

Note that we use <code>myPort.readStringUntil()</code>, which we can do because we are sending a string on the serial port from our Arduino program that is looping on the microcontroller. If we send other data-types, we would have to use a different function so Processing knows how to convert the un-typed data that is coming through the port at the specific baudrate.<br><br>

Next, check if this is working. We recommend you <a href="https://processing.org/reference/print_.html">print()</a> the String value to the Processing command line, run your Processing program, and touch your touch sensor to see if something gets printed on the Processing command line. If that doesn't work for you, now would be a good moment to get some help.<br><br>

<h4>Creating a Visualization for the Incoming Touch Sensor Data</h4><br>

Now we can do something based on the incoming Strings.<br>
In the next step, we want to create a bar that goes up if the touch sensor is touched and down if the sensor is not touched.</br>
Let's start with a single bar for touch sensor 1 and we can do the rest later.<br>


<img src="images/lab2-bar-down.png" width="300px">
<img src="images/lab2-bar-up.png" width="300px"><br>

Let's first create the bar with a fixed width of 100px and a fixed height of 300px.<br>
Here are some useful references:<br><br>

For setting the size of your application window:<br>
<ul>
  <li><a href="https://processing.org/reference/size_.html">size()</li>
</ul>
<br>

For drawing the rectangle:<br>

<ul>
  <li><a href="https://processing.org/reference/rect_.html">Rect</a></li>
  <li><a href="https://processing.org/reference/rectMode_.html">RectMode</a></li>
</ul>
<br>

For coloring the bar and the background:<br>
<ul>
  <li><a href="https://processing.org/reference/fill_.html">Fill</a></li>
  <li><a href="https://processing.org/reference/background_.html">Background</a></li>
</ul>

<br>

Once you are done it should look like this:<br><br>

<img src="images/lab2-bar-up.png" width="300px"><br>

Next, we can connect the height of the bar to the incoming touch sensor data coming from the serial messages in our Processing Script.<br>
But before we can do this, we first have to do some String Processing on the incoming message.<br><br>

<h4>Splitting the Incoming Message String into Individual Values</h4><br>

What we are currently printing to the command line are String in the format of "0,1;" (sensor_ID,is_touched;).<br>
However, to analyze this data in our code we have to split it again into two individual values so we can check the sensor_ID and and if the sensor is touched or not with an if/else statement.<br><br>

Use the String split() function to do that.<br>
You can find information on split() and how to use it in the <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html" target="_blank">Java String reference</a>.<br>
Once you have both the <code>sensor_ID</code> and <code>is_touched</code> separated, we recommend you check that this worked by printing them to the command line before moving on.<br><br>

<h4>Connecting the Incoming Touch Signals to the Visualization</h4><br>

Next, we will connect the height of the bar to the incoming touch signal.<br>
A high bar shows that the sensor is being touched.<br>
A low bar shows that the sensor is not being touched.<br><br>

<b>Tips</b>
<ul>
  <li>If you plan to use a boolean in Processing, the datatype is spelled out <code>boolean myVariable;</code> not <code>bool</code> like in Arduino.</li>
  <li>If you do a String comparison, remember you cannot use <code>stringVariable == "StringValue"</code>, instead you need to use <code>equals()</code>, check the reference here <a href="https://processing.org/reference/String_equals_.html">equals()</a></li>
  <li>Don't forget to clear the background at the beginning of the draw() function. Otherwise, you are just drawing each update on top of the previous update, so you may actually not see the bar changing since a shorter bar overlaid over a longer bar is not visible. Use <code>background(255,255,255);</code> or any other color you like.</li>
</ul>

<br><br>

Once you are done, it should look like this:<br><br>

Left: not touched, right: touched.<br>
<img src="images/lab2-bar-down.png" width="300px">
<img src="images/lab2-bar-up.png" width="300px"><br>

 
<h4>Extend Visualization to Three Bars</h4><br>

Next, we want to extend our user interface to have a bar for all three touch sensors.<br>
It should look like the image below.<br><br>

Only touch button 1 is touched, touch button 2 and 3 are not touched.<br>
<img src="images/lab2-three-bars-one-touched.png" width="300px"><br><br>

Touching multiple touch sensors simultaenously already works because we are reading messages from the serial port at such a high speed that they come after one another.
<br><br>

Only touch button 1 and 2 are touched, touch button 3 is not touched.<br>
<img src="images/lab2-three-bars-multiple-touched.png" width="300px"><br><br>


<!-- We created a Processing script for you that has the bars already implemented but lacks the Serial Communication.<br> -->
<!-- You can download the script here: <a href="images/lab2/Serial_Processing.zip">SCRIPT</a><br><br>     -->

<h4>Prepare for playing music: Install Processing 3 Sound Library</h4><br>

Now that we have basic touch input working in Processing, we can connect it to our music play application.<br>
To install the Processing Sound Library, go to <b>Sketch -> Import Library -> Add Library</b>.<br>
Then in the 'Libraries' Tab, search for 'sound' and install the one that is officially from Processing (see image below).<br><br>

<img src="images/lab2-add-library.png" width="300px"><br><br>
<img src="images/lab2-add-library-sound.png" width="600px"><br><br>

<h4>Run Skeleton Code</h4><br>

Once you have the library installed, download the <a href="software/music_card_nosolution.zip">skeleton code we provide for you from here</a>.<br>
Inside the folder, open and run the <b>music_card_nosolution.pde</b>, it will take a little while to load until you see the music card image in the view because we also load the mp3 audio files for the songs, which takes some time.<br>
You should see the music card being loaded into your application as shown below. If you don't see it, please let us know.<br><br>
    
<img src="images/lab2-loadedcard.png" width="600px"><br><br>

<h4>Add Touch Buttons onto the Card</h4><br>

Next, we want to mark the three notes as digital touch buttons.<br>
We will use the: <br>
<ul>
  <li>left touch button for previous song</li>
  <li>middle touch button for play/pause</li>
  <li>right touch button for next song</li>
</ul>

<br>

To make this easier for you, we already implemented a class 'Buttons' for you.<br>
You can make a new button with:<br><br>

<pre><span style="red">myButtons.add(new Button(x_top_left, y_top_left, x_bottom_right, y_bottom_right, drawing-mode));</span></pre>

Please add your buttons to line 47 onwards.<br>
One of the buttons is already defined there:<br><br>

<pre>myButtons.add(new Button(80.0, 160.0, 160, 240, "Ellipse")); //line 47</pre><br>
    
Your final result should look like this:<br><br>
    
<img src="images/lab2/card_buttons.png" width="300px"><br clear=all><br>

<h4>Create Touch Events for Playing / Pausing the Music and Next/Previous Song</h4><br>

To create events on mouse click, we need to implement several mousePressed() events.<br>
We already did this for you in the code further down in the class.<br>

<img src="images/lab2-button-presses.png" width="600px"><br clear=all><br>

We first iterate over all the buttons you created and then depending on the button ID, we want to execute a music function.<br>
We created a music class that loads several example songs in your project folder and has the functions:<br><br>
<pre>music.play();
music.pause();
music.back();
music.forward();
</pre><br>

You can see in the switch/case code that we already assigned the middle button to play and pause music.<br><br>

Extend the code to also go to the next and previous songs.<br>
Click onto the virtual touch buttons, i.e. onto each note, to see if your code works.<br><br>

<h4>Hide the Touch Buttons</h4><br>

While we want to have a touch button on each note, we don't want to see the white ellipses since they make the card look less good.<br>
We already prepared a piece of code for this for you:<br>
Press the 'h' key on your keyboard while your program runs.<br>
It will hide the buttons but you can still click on them.<br>
If you want to see them again, press 's' (for show).<br>
Study the code to see where this was implemented and how we did it.<br><br>

<h4>Now let's play some music from the Inkjet Printed Physical Card</h4><br>

Now that we have the user interface that we can control digitally and we tested that everything works by clicking onto each note to play/pause and go to previous/next song, we also want to play some music from the physical card.<br><br>

We have already implemented the Serial communication and the message decoding in the previous exercise, i.e. the Processing application you wrote for displaying the touch bars that go up and down. <br>
Add this code to the music card UI and instead of increasing the height of your bar you are now calling the music functions. <br><br>

Once you have finished the code, try if it works by touching the notes of your printed music card to play/pause the song and go to the next/previous song.<br><br>

<h3 class="headline">(6) Wiring up and Visualizing the Slider for Volume Control</h3> <br>

Now that we have successfully wired up the touch buttons, processed the touch signals, and visualized them in Processing, we want to do the same three things for the touch slider.<br><br>

<h4>Connect the Physical Slider to the Main Circuit.</h4><br>

Start by wiring up each slider segment exactly the way how you wired up the individual touch buttons.<br>
Remember they can all use the same sender pin but need a different receiver pin.<br>
<a href="lab1-circuit-design-and-processing.html">Refer to Lab 1</a> if you don't remember how this works.<br><br>

Here is the pin out again for your reference.<br>
Remember, use the pins with "TOUCHX" labels for better signal quality but <b>do not use the one pin labeled as pin0 (TOUCH1) as receiver</b> (you can still use it as sender).
 <br><br>

<img src="images/esp32-pinout.png" width="500px" /><br><br>

<h4>Thresholding Slider Signals: How much space is it touched?</h4><br>

Once finished with the wiring, extend the Arduino code so that it can also read each slider segment's touch signal.<br><br>

For the touch buttons, we were merely interested if the button is touched or not, thus we converted the touch signal into a <b>binary value 0 or 1</b> to indicated if it is pressed or not.<br>
Remember that for the slider we want to do something more sophisticated, i.e. have a continous signal that allows us to smoothly adjust the music volume (rather than jumping from one discrete noise level to the next).<br>
Thus, each slider segment should return a <b>continuous value from 0.0 to 1.0</b> when touched depending on the area of overlap with the finger. <br><br>

We can see by 'how much' a slider segment is touched by looking at the raw touch signals coming from the microcontroller.<br>
When looking at the Serial Plotter, you will notice that the raw value has a strong correlation with how much space of the sensor is touched, i.e. the larger the area the higher the value is. <br><br>

Thus, you can compute continuous value for each slider segment via 2 parameters (see below): <br>
1) threshold to see if it is touched or not (i.e. 'min touch value'), and <br>
2) the 'max touch value' of the slider segment when fully touched. <br><br>

You can then calculate and print the percentage by "raw_value / max_touch_value" in real-time if the value surpass the "touched" threshold. <br><br>

<img src="images/lab2-slider-value.png" width="600px" /><br><br>

Once you have the continous signal for each slider segment, you need to format the result and write it to the Serial port so that we can read it from Processing. <br>

For each sensor (slider segment), format the output like we did before for the touch button so that:

<code>(sensor ID),(how_much_touched);</code><br><br>
    
(sensor ID) is from 3 - 7, and represents the ID of each slider segment.<br>
(is_touched) is ranging from 0.00 to 1.00 to indicate how much space the sensor is touched.<br><br>

<span style="color:red">is this a realistic example? I thought max 2 slider segments will be touched?</span><br>
A sample output hould look like:<br>
<pre><code>3,0.78;
3,0.86;
5,0.64;
7,0.97;
</code></pre> 
The output should print continuously as long as the corresponding slider segment is touched. <br>

<br>

<h4>Create Slider Visualization</h4><br>

Now that the slider segment values are printing to the Serial port, we can read them from Processing.<br>
<span style="color:red">Open your Processing program that had the three touch bars and add a horizontal bar for the slider.<br> 
The bar represents the entire slider. Thus, if the finger is on the left side of slider, the bar should be short and if the finger slides more to the right side of the slider, the bar should be long.</span><br><br>

However, before we can render the current slider value on the bar, we will have to do something with the five seperate slider segment values and combine them into one value that represents the overall slider position ranging from 0.00-1.00 (0-100 percent).<br>
You don't have to over-complicate it, some straght-forward linear interpolation will do, as long as the value is overall continuous.<br>  <span style="color:red">can you say a bit more how you did this? what did you average together?</span><br>

<img src="images/lab2-slider-viz.png" width="300px"><br><br>

<h4>Add Slider onto the Card</h4><br>

Now that you know the slider values can be visualized in Processing, let's add it to the music card to control the music volume.<br> Open the music card code again.<br><br>

We already implemented a class 'Slider' for you.<br>
You can make a new slider with:<br><br>

<pre><span style="red">mySliders.add(new Slider(start_x, start_y, end_x, end_y));</span></pre>

Please add one slider to the code, just like how you added the button. <br>
Add code to the draw() function to display the slider when it is not in "hide" mode.<br><br>

Your result should look like this.<br>
You should be able to control the slider by dragging your mouse (with left mouse button pressed): <br><br>

Dragging the mouse on the slider from left to right:<br>
<img src="images/lab2-volume-low_UI.png" width="300px">
<img src="images/lab2-volume-middle_UI.png" width="300px">
<!-- <img src="images/lab2-volume-high_UI.png" width="200px"> -->
<br><br>

<h4>Create Slider Events for the Music Volume Control</h4><br>

To create events on mouse drag, we need to implement several mouseDragged() events.<br>
We already did some parts of it for you in the code further down in the class.<br>
Please go ahead and extend the code so that it changes the music volume based on the slider level. <br>
You might find the following functions from the "Audio" and "Slider" classes useful: <br>
<br><pre>
music.changeVolume(double intensity);
Slider.getIntensity();</pre><br><br>

Once you finished your code, test if the music volume actually changes by first playing a song with the virtual touch button and then dragging the slider to adjust the music volume. If everything works, move on.<br><br>

<h4>Hide the Slider</h4><br>

Similar to the previously added buttons, you can hide the Slider by pressing the 'h' key on your keyboard while your program runs.<br>
If you want to see them again, press 's' (for show).<br><br>

<h4>Now Let's Change Music Volume from the Inkjet Printed Physical Card</h4><br>

Now that we can control the slider digitally, we also want to adjust the volume of the music from the physical card.<br><br>
Copy over your code from the other Processing application you just wrote and integrate it into the music card.<br>

<img src="images/lab2-volume-low.png" width="300px">
<img src="images/lab2-volume-middle.png" width="300px">
<!-- <img src="images/lab2-volume-high_UI.png" width="200px"> -->
<br><br>

Now test if everything works by using your physical printed card to play/pause songs and the physical slider to adjust the music volume. If it works, congrats, you are done :)!<br><br>


<h3 class="headline">Conclusion</h3>

Now we can read microcontroller input and display it in Processing. <br>
This will come in handy in the future when we want to build and test more advanced user interfaces.<br><br>

<br>

    
<!--   This means that when touching one of the touch buttons, your ESP should send a message to your computer that the Processing script can understand and change its background color.
 -->

<!--  In particular, we are going to wire up a button, and when the button is pressed, we will show this in Processing by coloring the corresponding button in the digital UI and starting a song.<br><br>
<!--
<h4>Replacing the Standard Button with your Printed Touch Button</h4><br>

We hope you received your custom touch button from last week. If not, your original package has a standard printed touch button (square) that you can use instead.<br><br>

We are now going to replace the standard touch button with your custom touch button.<br>
First, use the multimeter to check if you touch button is conductive and didn't break during transport.<br>
If you don't remember how to use the multimeter, check last week's tutorial.<br><br>

<img src="images/multimeter.jpg" width="300px"><br><br>

Ok, if your multimeter shows low resistance, we are ready to wire up your touch button.<br>

<b>Electronics:</b> To build the circuit to implement touch sensing you only need your touch sensor and one resistor (say some more why this is necessary). Low resistors (1kOhm - 100kOhm) are mostly used for sensing touch (see Figure below).<br><br>

<img src="images/touch-sensing-principle.png" width="300px"> <img src="images/touch-sensing-circuit.png" width="300px"><br><br>

<img src="images/touch-sensor-on-breadboard.jpg" width="300px"> <img src="images/touch-sensor-on-breadboard-schematic.png" width="300px"><br><br>

<b>Connecting the Touchbutton to the microcontroller:</b> To connect the touch button to the microcontroller and remaining electronics, we are going to use conductive tape. Cut a piece of conductive tape and attach it to the connector pad and then to the end of a wire that goes to the microcontroller (would be great to have the break out board so this is less messy).<br><br>

<b>Code:</b> Once you build your circuit, you can write the code to read input from your touch sensor. Capacitive touch sensing is luckily already supported by the Arduino Toolkit.<br><br>

Download the latest <a href="https://github.com/PaulStoffregen/CapacitiveSensor"> library CapacitiveSensor for Arduino from here</a> and place it into your Documents / Arduino / Libraries folder (unzip it and rename it to 'CapacitiveSensor'). Restart your Arduino software, otherwise the library is not recognized.<br><br>

First you need to import the library:<br>  
<code>#include CapacitiveSensor.h</code><br>  <br>  

Next, you need to create a new CapacitiveSensor object:<br>  
<code>CapacitiveSensor sensor1 = CapacitiveSensor(sender, touch_pin_1);</code><br>  
It takes as input the pin that has the high signal and the receiver pin.<br><br>  

In the loop function, you are now ready to read from the sensor.<br>  <br>  

<code>double analog_touch = sensor1.capacitiveSensor(samples_touch);</code><br>  
The argument <b>samples</b> defines the sensitivity of the sensor.<br>  <br>  
For touch sensing a low sensitivity is common with samples between 1 and 20. <br><br>

If you print analog_touch to the Serial monitor and you touch your touch button, you should be able to see the values change quite drastically. Do some simple thresholding to determine when the button is pushed and when it is not pushed (e.g., values above XX equal pushed, values below XX equal unpushed). <br><br> 

<div style="background:#04a47c;padding:10px;">Checkoff 2: Show your working touch sensor that when pushed, prints 'pushed' to the Serial monitor and otherwise prints 'unpushed'.</div><br>

 <h3 class="headline">Performing Input in Processing<br> and Using it on the Microcontroller</h3>

Let's do it the other way around and write some output from Processing onto the microcontroller.<br>
In our simple example, we will light up an LED when the user clicks a button in the Processing UI, and then later replace it with our printed EL display.<br><br>

<h4>Wiring Up an LED and Write Basic On/Off Code</h4>

Let's start by wiring up an LED on the breadboard and writing the basic code to turn the LED on/off. <br>
If you haven't coded in Arduino for a while, you may want to look at 'Examples -> Blink' to see how to read input from a pin and turn your LED on/off.<br><br>

<img src="images/led-on-breadboard.jpg" width="250px"> <img src="images/led-on-breadboard-schematic.png" width="350px"><br><br>

<h4>Create Microcontroller Script that Reads from Serial Monitor</h4>

Once you confirmed that your LED works (i.e. you tested it turns on), we will now write a piece of Arduino code that will listen to the Serial communication and whenever it encounters a '2' it will light up the LED and when it encounters a '3' it will turn the LED off.<br><br> 

This part is very similar to the previous Arduino code, just that instead of Serial.write() you are now going to use <a href="https://www.arduino.cc/reference/en/language/functions/communication/serial/read">Serial.read()</a> to determine if a 2 or 3 was send and the LED should be on or off.<br><br>

Complete the rest of the Arduino script for turning on/off your LED by reading from the Serial connection and upload it to the microcontroller.<br>
We will test this in a moment when we connect it to Processing.<br><br>

<h4>Create Processing Script that Writes to Serial Monitor</h4>

Once you uploaded your Arduino code, we are now ready to write a Processing script to write to the serial connection the '2' or '3' values, which can then be used by the Arduino code to decide if the LED should be on or off.<br>
Whenever a button is clicked in the Processing UI, we want to write a '2', otherwise a '3'. <br><br>

The setup code is the same as in the previous Processing example above, but now you are using<br>
<code>myPort.write(2); // 2 or 3 depending on state</code><br><br>

        <!--
    
<h4>Blinking LED to Beat</h4><br>

To blink the LED to the beat, we prepared this custom Processing script for you.<br>
All you need to do is to send a '2' or '3' whenever our script tells us that the beat just happened.<br>

<div style="background:#04a47c;padding:10px;">Checkoff 3: Show your working LED that can be turned on by pushing the button in Processing and can also blink to the beat of a song.</div><br><br>

<h4>Replacing the Standard LED with your Printed Display</h4><br>

With that information in mind, we are now ready to connect your EL display to the microcontroller.<br>
First, use the multimeter to check if your display is conductive and didn't break during transport.<br>

<img src="images/multimeter.jpg" width="300px"><br><br>

Ok, if your multimeter shows low resistance, we are ready to wire up your EL display.<br>

<b>Electronics:</b> To light up your EL display, you need to build the following circuit (add more information here).<br><br>

<b>Connecting the Display to the microcontroller:</b> To connect the display to the microcontroller and remaining electronics, we are going to use conductive tape. Cut a piece of conductive tape and attach it to the connector pad of the display and then to the end of a wire that goes to the microcontroller (would be great to have the break out board so this is less messy).<br><br>

<img src="images/touch-sensing-circuit.png" width="300px"><br><br>

<b>Code:</b> Once you build your circuit, you can write the code to light up your EL display (add more information here). <br><br>

    
<h4>Connecting EL Display to Processing</h4><br>

Now that you know your EL display is working properly, you can make it light up based on the information coming from the Serial communication, i.e. the beat of the song. Replace the hard coded on/off for the EL display with the '2' or '3' date you are reading from the Serial monitor. <br><br>


<h2 class="headline">Miniatiarizing the Microcontroller</h4>

Right now, we are using a pretty big and clunky microcontroller, which doesn't integrate well with our design.<br>
In the final step today, we want to replace the big microcontroller with a smaller one: the ATTiny.<br>

<img src="images/attiny.jpg" width="300px"><br><br>

Looking at this image, you may have a few questions, such as how to know which pin is which since nothing is labeled and how to program the thing since there is no space for a USB cable connection!<br><br>

<h4>Identifying Pins on the ATTiny</h4><br>

To find our which pin is which, you first need to know where is the top left corner of the Attiny. If you look very closely, you can see a small dot on the top black surface. The small dot indicates the top left corner of the controller. Once you know which corner is the top left, you can search for the <a href="https://components101.com/microcontroller/attiny85-pinout-datasheet">data sheet of the ATTiny on google</a>.<br><br>

<img src="images/attiny-top-left.png" width="200px"> <img src="images/attiny-datasheet.png" width="350px"><br><br>

Ok great, so now you know where VCC and GND are and where the data pins are for analog and digital communication.<br>
However, the question still remains, how to upload code.<br><br>

<h4>Uploading Code to ATTiny</h4><br>

There are several different ways how to program an ATTiny, one of the most straight forward is to use a device, such as the Tiny Programmer, see below.<br>

<img src="images/attiny-programmer.png" width="200px"> <br><br>

To program your ATTiny, you simply put it in the slot with the breadboard pins.<br>
In the next step, you then connect jumper wires to go from the connecting pins to your breadboard.<br>
You can use the USB connection on the Tiny Programmer to connect to your laptop.<br>

<img src="images/tiny-programmer-in-action.png" width="500px"> <br><br>

Once you confirmed that your code is correct and everything is working, you can move the ATTiny off the Tiny Programmer and put it onto your breadboard where it will keep looping its code there to perform its function.<br><br>

<h4>How to get Rid of the Breadboard? SMD Components. </h4><br>

Ok so this is already better than before, but still not great because we still have the breadboard there.<br>
So far, you have used for the ATTiny is called a DIP (dual inline package) that has two rows of pins that needly fit into a breadboard. To make it even smaller, you can get the same ATTiny as an SMD (surface mount device), which means it will not have pins but instead needs to be soldered onto a PCB.<br><br>

To produce the ATTiny as an SMD on a PCB, we used (this PCB manufacturing facility) and gave them (this specification) and (these design files). As a result, we got the following SMD component back.<br><br> 

<img src="images/attiny-smd.jpg" width="300px"> <br><br>

Ok, so now we are back at square one, how do we program the thing? Since it doesn't have pins anymore, it doesn't fit into the Tiny Programmer.<br>
Lucky for us, there is <a href="https://www.amazon.com/gp/product/B00HHH65T4/ref=ppx_yo_dt_b_asin_title_o00_s00?ie=UTF8&psc=1">another device for this</a> that you can see below.<br><br>

<img src="images/attiny-testclip.png" width="300px"> <br><br>

To use it, you clamp the front onto your ATtiny.<br>
Then you use jumper wires to connect the upper part back to the Tiny Programmer (Stefanie: I will try this out and update here once I know more).<br><br>

<img src="images/attiny-testclip2.png" width="300px"> <br><br>

<h4>Attaching the SMD Microcontroller to the rest of the Circuit with Z-Tape</h4><br>

Now that we have programmed the ATTiny PCB, we can attach it to our card.<br>
If you flip your ATTiny and look at the back you can see that we create the PCB as a double-sided PCB, i.e. the connections extend all the way to the back.<br><br>

<img src="images/attiny-front.jpg" width="300px"><img src="images/attiny-back.jpg" width="300px"> <br>
Front and back of the ATtiny PCB.<br><br>

We can now use z-tape and attach it to the back of the PCB.<br>
ztape is a special tape that conducts vertically but isolates horizontally.<br>
Once the ztape is on, you can peel back the other side of the ztape layer and attach it to your card.<br>
(Stefanie: If we want to do this part, we need to ask them to redraw their wire connections so they fit the ATTiny and not the ESP32. Perhaps this could be a good moment to use the silver pen?)<br><br> 

-->

<!--  <h3 class="headline">Bringing it all together</h3>

 -->



        <br />
        <br />
        <br />
      </section>

      <aside class="col-md-4 pull-left">
         <br /> <br /> <br /> <br />
<!-- 				 <h4>Pset Steps</h4><br>
				 <ul>
		 			<li><a href="#pset1">pset1 (due Sept. 21, 11.59pm): laser cut and bend the acrylic base</a><br /></li>
		 			<li><a href="#pset2">pset2 (due Oct. 5, 1pm): insert LEDs, add USB connecting and solder everything</a><br /></li>
		 			<li><a href="#pset3">pset3 (due Oct. 19, 1pm): write touch recognition so that you can determine (x,y) location of each finger</a><br /></li>
		 			<li><a href="#pset4">pset4 (due Oct. 26, 1pm): add an application of your choice</a><br /></li>
				</ul>
				<br /> <br /> <br /> <br />
        <img src="../2018-fall-6810/images/multi-touch-pad/iap1.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad/iap2.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad//iap3.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad/iap4.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad/iap5.jpg" width="220px">
 -->



        <!-- Publication -->

        <br><br><br><br><br>

        <!-- Publication -->

<!-- <h4>Side Bar</h4><br>

    <ul>
      <li>Prof. Stefanie Mueller (Instructor)</li>
      <li>Lotta-Gili Blumberg (TA)</li>
      <li>Xin Wen (UTA)</li>
      <li>Loren Maggiore (LA)</li>
      <li>Mark Chounlakone (LA)</li>
    </ul>
 -->
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>

      </aside>

    </div>
  </div>
  </div>
</section>

<div class="container">
	<div class="row">
		<div class="col-md-12 footer" style="text-align: center;">
			<span class="copyright">
			Since 2017 &copy; MIT CSAIL (HCI Engineering group) [redesign by
			<a href="http://punpongsanon.info/" target="_blank" style="text-decoration:none; border-bottom:0px">
			moji
			</a>].
			All Rights Reserved.

			<a href="http://mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/mit.svg" alt="MIT" class="footer-logo" />
			</a>
			<a href="http://csail.mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/csail.svg" alt="CSAIL" class="footer-logo"/>
			</a>
			<a href="http://hci.csail.mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/hci.svg" alt="HCI" class="footer-logo"/>
			</a>
			</span>
		</div>
	</div>
</div>

<!-- Bootstrap -->
<script type="text/javascript" src="../../js/bootstrap.min.js"></script>
<!-- header -->
<script type="text/javascript" src="../../js/headerstrap-for-subpage.js"></script>

</body>
</html>
