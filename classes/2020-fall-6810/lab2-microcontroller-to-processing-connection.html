<!DOCTYPE html>
<html>
<head>
	<title>HCI Engineering Group</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

	<!-- CSAIL ICON -->
	<link rel="CSAIL" href="../../../images/icon/csail.ico" type="image/x-icon" />

	<!-- Bootstrap -->
	<link href="../../css/bootstrap.css" rel="stylesheet">
	<link href="../../css/custom-style.css" rel="stylesheet">

	<!-- jQuery -->
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

	<!-- Google Fonts -->
	<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Abel" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Barlow" rel="stylesheet">

	<!-- Google Analytic -->
	<script type="text/javascript" src="../../js/analytics.js"></script>

	<style>
	.etech-sch-col1 {width:60px; border: 1px solid black;padding:10px;}
	.etech-sch-col2 {width:120px; border: 1px solid black;padding:10px;}
	.etech-sch-col3 {width:450px; border: 1px solid black;padding:10px;}
	.etech-sch-col4 {width:70px; border: 1px solid black;padding:10px;}
  .etech-sch-col5 {width:70px; border: 1px solid black;padding:10px;}
  /*.etech-sch-col6 {width:170px; border: 1px solid black;padding:10px;}*/
  ul {
    padding:0px;padding-left:10px;margin:0px;
  }
	</style>
</head>

<body>
<header class="main_header">
	<!-- to be filled by javascript, see header.html -->
</header>

<section class="main_container">
	<div class="container">
    <div class="row nothing">

      <section class="col-md-8 pull-right main-content">
</br></br></br></br>
        <h4 class="medium.headline"><a href="6810-engineering-interactive-technologies.html">6.810 Engineering Interactive Technologies (fall 2020)</a><br></h>
        <h2 class="headline">Part 2: Connecting Micro-controller to UI</h2>
      
          <hr>

          <!-- Code in: Documents / Processing / SimpleRead --> 
          <!-- Code in: Documents / Arduino / serial-write -->
          <!-- Code in: Documents / Processing / SimpleWrite -->
          <!-- Code in: Documents / Arduino / serial-read -->

<h2 class="headline">Your Task for Today</h2>

In the last lab, we have already done steps 1-4 to get our interactive music card going.<br>
Today, we are going to connect your last lab's card design to Processing: When you push the physical touch button it will light up the corresponding digital touch button in Processing and the associated song will play.<br><br>

<b>(done) (1) Circuit Design :</b> You will first draw the circuit design of your card by creating a 2D drawing of the wires and interactive touch and slider areas.<br>
<b>(done) (2) Conductive Silver Inkjet Printing:</b> Next, you will print your design with conductive inkjet printing.<br>
<b>(done) (3) Wiring up the Circuit:</b> In the next step, you will wire up your circuit using a breadboard and an ESP32 microcontroller.<br>
<b>(done) 4) Sensing the Touch Signals:</b> Next, you will sense the touch signals using the CapacitiveSensor Library and apply filtering to the signals.<br>
<b>(today) (5) Visualizing User Input:</b> Finally, we will setup the touch buttons and sliders in a programming environment called Processing, which will visualize when physical input on the touch buttons and sliders on screen and also play the corresponding songs. <br><br>

<h4>Make sure everything from last lab is still working</h4><br>

Before getting started with the new content, let's first make sure everything from last time is still working and no wires came lose.<br> 
To do this, connect your music card and ESP32 again to your computer via USB and upload the program that you haven written in the last lab.<br> 
Double check that everything is still working, i.e. when touching one of the touch buttons you should see the touch signals show on the Serial monitor.<br><br>

 <h3 class="headline">(5) Visualizing User Input with Processing</h3><br>


<h4>Receiving Touch Input in Processing:<br> Create Processing Script that Listens to Serial Communication</h4><br>

In the last lab, we sent the touch input to the Arduino IDE and plotted it in the Serial Monitor or Serial Plotter.<br>
Since Arduino has no libraries for graphical user interfaces, we now want to instead send our touch input to Processing.<br>
<br>

<a href="https://processing.org" target="_blank">Processing</a> is a user interface protoyping platform that is based on Java. It was created by MIT students (and others) in their spare time starting in Spring 2001 and is nowadays used by thousands of makers and UI designers. You can find useful information on how to use it in their <a href="https://processing.org/tutorials/" target="_blank">tutorial section</a>.<br><br>

In the last lab, we encoded a touch event in the format:<br><br>

<code>(sensor ID),(is_touched)(newline)</code><br><br>
    
(sensor ID) is either 0, 1 or 2 and represents the ID of the observed touch sensor.<br>
(is_touched) is either 0 or 1 (0 if the sensor is not touched, and 1 if it is touched).<br><br>

And wrote it to the Serial port using <code>Serial.print()</code>.<br><br>

In order to use this information in Processing, we need to write a Processing script that listens to the Serial communication.<br><br>

To do this, open Processing and import the <a href="https://processing.org/reference/libraries/serial/index.html">Serial library</a>.<br>
<pre>import processing.serial.*;</pre><br>

Next, you need to create a new port that can be used for communication by creating an object from this class: <br>
<pre>Serial myPort;</pre><br>

To define the port, you need to define three things: (1) you need to tell the port which application will listen to it, you can do this with a reference to the current application ('this'), (2) you need to tell the port its portname, and (3) you need to tell the port at which baudrate it should listen to be able to decode the messages. <br><br>

<pre>myPort = new Serial(this, portName, baudrate);</pre><br>
    
For the <code>portName,</code> you can get a list of all avaialble ports from the Serial library.<br> 
By accessing different buckets of the list, you can get access to the name of each port.<br>
Check if the correct portname is in bucket 0, 1, or 2 by printing it.<br><br>

<pre>// check which port you use: 0, 1, 2?
String portName = Serial.list()[2];
print(portName);</pre><br>

For the <code>baudrate</code>, you already know this from your Arduino program that you uploaded to the microcontroller.<br>
Check in your Arduino program with which baudrate you initialized the Serial communication.<br>
If you use a different baudrate that you wrote into the Arduino program, you will only get a lot of random stuff back.<br><br>

Now that your port is defined, we are ready to listen to it and check if data is available, but before we do this let's briefly look at the Processing program structure.<br><br>

<h4>Processing Program Structure: setup() and draw() functions</h4><br>

Similar to Arduino, every Processing program has two functions: one that is run only once (setup()) and one that is looping forever (draw()).<br><br>

Before we move to the next step, let's create a setup function:<br><br>

<pre>
void setup() { // runs only once
  
}
</pre><br>

and move all your setup code for defining the port there.<br><br>

Next, create an empty draw function:<br>

<pre>
void draw() { //runs infinitely
  
}
</pre><br>

We are going to fill this in the next step.<br><br>

<h4>Reading Data from the Serial Port</h4><br>

Now that we have the port defined, we can see if data is available.<br>
In the draw function, you need to first check if there is data on the port available, and then you can read the value from the port.<br><br>

<pre>int val;
if (myPort.available() > 4) { // If there is a message with at least 4 characters because we are sending in the format [sensorNumber comma touched semicolon] with one character each
    String val = myPort.readStringUntil(';'); // reads a String until the character ';' is found
  }</pre><br>

Note that we use <code>myPort.readStringUntil()</code>, which we can do because we are sending a string on the serial port from our Arduino program that is looping on the microcontroller. If we send other data-types, we would have to use a different function so Processing knows how to convert the un-typed data that is coming through the port at the specific baudrate.<br><br>

Next, check if this is working. We recommend you print() the String value to the Processing command line, run your Processing program, and touch your touch sensor to see if something gets printed on the Processing command line. If that doesn't work for you, now would be a good moment to get some help.<br><br>

<h4>Visualizing the Incoming Touch Sensor Data</h4><br>


Now you can do something based on the String.<br><br>
    
In the last lab, we encoded a touch event on the printed UI in the format:<br><br>
(sensor ID),(is_touched);<br><br>

Your task is to visualize the incoming serial messages in a Processing Script. We will see 3 bars that go up and down if one or multiple of the physical buttons get touched. It should look like this:<br><br>
    
<img src="images/lab2/processing_bars.png" width="300px"><br clear=all><br>
    
We created a Processing script for you that has the bars already implemented but lacks the Serial Communication.<br>
You can download the script here: <a href="images/lab2/Serial_Processing.zip">SCRIPT</a><br><br>
    
Your task is to add the Serial communcation that receives the touch signal from your printed touch sensors and show their state with the 3 bars, i.e. a high bars shows that the sensor is touched and a low bar shows that the sensor is not touched. You can use the 3 boolean variables touch_0, touch_1, and touch_2 in the script to this end. <br><br>
    
You will have to split the incoming message into its two parts (sensor_ID) and (is_touched). Use the String split function to do that. You can find information on how to use it in the <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html" target="_blank"> Java String reference</a>.<br><br>
<pre>String[] sensor_data = val.split(",");</pre><br>
    
<h4>Combine the Physical Interface with a Digital Application</h4><br>

We created the skeleton of a music interface for you. First step is to download the skeleton <a href="software/music_card_nosolution.zip">"here"</a> and confirm that you can run it.<br><br>
    
Next, we want to implement touch buttons in the UI that start/pause the music, and two buttons for moving to the next or the previous song<br><br>
    
We start by adding digital buttons to the music card UI. We created a class "Buttons" that lets you create buttons in Processing:
<pre>myButtons.add(new Button(80.0, 160.0, 160, 240, "Ellipse")); //line 45</pre>
    
The parameters (a,b,c,d,type) are necessary to define an ellipse shaped button. (a,b) is the upper left corner, and (c,d) is the lower right corner of a rectangle that covers the ellipse. "type" lets you set it to be an ellipse. You don't have to change anything about the type.<br><br>
Now, add 3 buttons to the UI (line 45). Your final result should look like this:<br><br>
    
<img src="images/lab2/card_buttons.png" width="300px"><br clear=all><br>

Next, we want to assign 3 functions to these buttons: "play/pause", "next song", and "previous song". We created a music class that loads several example songs in your project folder and has the functions:<br><br>
<pre>music.play();
music.pause();
music.back();
music.forward();</pre><br>
    
Find the mousePressed(MouseEvent evt) function and add a next song, and previous song button functionality to the left most and right most button. The button in the middle sould be the play button. We implement as an example the play/pause button:<br><br>
<pre>switch(i) {
           case 0 : if(!music.getPlaying())
                      music.play();
                    else 
                      music.pause();
                    break;
          }</pre>
<br>
    
The digital UI is now almost ready. However, we don't want to see the white ellipses all the time but only the music card design. Try pressing the 'h' key on your keyboard while your program runs. It while hide the buttons but you can still click on them. If you want to see them again, press 's' (for show).<br><br>

Great! Now it is time to connect your serial communication messages from the printed music card to the digital UI. To do that, we have to write code to listen to a serial port, decode the messages from the previous lab and assign them to the music class in your digital UI. But everything step by step.<br><br>

We have implemented the Serial communication and the message decoding in the previous exercise. Add this code to the music card UI and add a command that prints the Serial message everytime you receive something. Make sure that the printed music card is connected properly and you listen to the right port.<br><br>
<pre>println("Serial message:" + val)</pre>

Check if you receive the messages:<br><br>
<img src="images/lab2/Serial_message.png" width="300px"><br clear=all><br>
    
Now, use the (sensor_ID) to address the right button and the (is_touched) message to trigger it. We implemented this already with the first button and let it start the playback of the music.<br><br>
<pre>if ( myPort.available() > 4) {
    val = myPort.readStringUntil(';');
    String[] msg = val.split(",");
    switch(msg[0]) {
       case "0": if(msg[1].equals("1")) 
                   music.play();
                 break;
    }
  }</pre><br><br>

Remember that msg[0] is the (sensor_ID) and msg[1] is the (is_touched) event. 
    
<!--   This means that when touching one of the touch buttons, your ESP should send a message to your computer that the Processing script can understand and change its background color.
 -->

<!--  In particular, we are going to wire up a button, and when the button is pressed, we will show this in Processing by coloring the corresponding button in the digital UI and starting a song.<br><br>
<!--
<h4>Replacing the Standard Button with your Printed Touch Button</h4><br>

We hope you received your custom touch button from last week. If not, your original package has a standard printed touch button (square) that you can use instead.<br><br>

We are now going to replace the standard touch button with your custom touch button.<br>
First, use the multimeter to check if you touch button is conductive and didn't break during transport.<br>
If you don't remember how to use the multimeter, check last week's tutorial.<br><br>

<img src="images/multimeter.jpg" width="300px"><br><br>

Ok, if your multimeter shows low resistance, we are ready to wire up your touch button.<br>

<b>Electronics:</b> To build the circuit to implement touch sensing you only need your touch sensor and one resistor (say some more why this is necessary). Low resistors (1kOhm - 100kOhm) are mostly used for sensing touch (see Figure below).<br><br>

<img src="images/touch-sensing-principle.png" width="300px"> <img src="images/touch-sensing-circuit.png" width="300px"><br><br>

<img src="images/touch-sensor-on-breadboard.jpg" width="300px"> <img src="images/touch-sensor-on-breadboard-schematic.png" width="300px"><br><br>

<b>Connecting the Touchbutton to the microcontroller:</b> To connect the touch button to the microcontroller and remaining electronics, we are going to use conductive tape. Cut a piece of conductive tape and attach it to the connector pad and then to the end of a wire that goes to the microcontroller (would be great to have the break out board so this is less messy).<br><br>

<b>Code:</b> Once you build your circuit, you can write the code to read input from your touch sensor. Capacitive touch sensing is luckily already supported by the Arduino Toolkit.<br><br>

Download the latest <a href="https://github.com/PaulStoffregen/CapacitiveSensor"> library CapacitiveSensor for Arduino from here</a> and place it into your Documents / Arduino / Libraries folder (unzip it and rename it to 'CapacitiveSensor'). Restart your Arduino software, otherwise the library is not recognized.<br><br>

First you need to import the library:<br>  
<code>#include CapacitiveSensor.h</code><br>  <br>  

Next, you need to create a new CapacitiveSensor object:<br>  
<code>CapacitiveSensor sensor1 = CapacitiveSensor(sender, touch_pin_1);</code><br>  
It takes as input the pin that has the high signal and the receiver pin.<br><br>  

In the loop function, you are now ready to read from the sensor.<br>  <br>  

<code>double analog_touch = sensor1.capacitiveSensor(samples_touch);</code><br>  
The argument <b>samples</b> defines the sensitivity of the sensor.<br>  <br>  
For touch sensing a low sensitivity is common with samples between 1 and 20. <br><br>

If you print analog_touch to the Serial monitor and you touch your touch button, you should be able to see the values change quite drastically. Do some simple thresholding to determine when the button is pushed and when it is not pushed (e.g., values above XX equal pushed, values below XX equal unpushed). <br><br> 

<div style="background:#04a47c;padding:10px;">Checkoff 2: Show your working touch sensor that when pushed, prints 'pushed' to the Serial monitor and otherwise prints 'unpushed'.</div><br>

 <h3 class="headline">Performing Input in Processing<br> and Using it on the Microcontroller</h3>

Let's do it the other way around and write some output from Processing onto the microcontroller.<br>
In our simple example, we will light up an LED when the user clicks a button in the Processing UI, and then later replace it with our printed EL display.<br><br>

<h4>Wiring Up an LED and Write Basic On/Off Code</h4>

Let's start by wiring up an LED on the breadboard and writing the basic code to turn the LED on/off. <br>
If you haven't coded in Arduino for a while, you may want to look at 'Examples -> Blink' to see how to read input from a pin and turn your LED on/off.<br><br>

<img src="images/led-on-breadboard.jpg" width="250px"> <img src="images/led-on-breadboard-schematic.png" width="350px"><br><br>

<h4>Create Microcontroller Script that Reads from Serial Monitor</h4>

Once you confirmed that your LED works (i.e. you tested it turns on), we will now write a piece of Arduino code that will listen to the Serial communication and whenever it encounters a '2' it will light up the LED and when it encounters a '3' it will turn the LED off.<br><br> 

This part is very similar to the previous Arduino code, just that instead of Serial.write() you are now going to use <a href="https://www.arduino.cc/reference/en/language/functions/communication/serial/read">Serial.read()</a> to determine if a 2 or 3 was send and the LED should be on or off.<br><br>

Complete the rest of the Arduino script for turning on/off your LED by reading from the Serial connection and upload it to the microcontroller.<br>
We will test this in a moment when we connect it to Processing.<br><br>

<h4>Create Processing Script that Writes to Serial Monitor</h4>

Once you uploaded your Arduino code, we are now ready to write a Processing script to write to the serial connection the '2' or '3' values, which can then be used by the Arduino code to decide if the LED should be on or off.<br>
Whenever a button is clicked in the Processing UI, we want to write a '2', otherwise a '3'. <br><br>

The setup code is the same as in the previous Processing example above, but now you are using<br>
<code>myPort.write(2); // 2 or 3 depending on state</code><br><br>

        <!--
    
<h4>Blinking LED to Beat</h4><br>

To blink the LED to the beat, we prepared this custom Processing script for you.<br>
All you need to do is to send a '2' or '3' whenever our script tells us that the beat just happened.<br>

<div style="background:#04a47c;padding:10px;">Checkoff 3: Show your working LED that can be turned on by pushing the button in Processing and can also blink to the beat of a song.</div><br><br>

<h4>Replacing the Standard LED with your Printed Display</h4><br>

With that information in mind, we are now ready to connect your EL display to the microcontroller.<br>
First, use the multimeter to check if your display is conductive and didn't break during transport.<br>

<img src="images/multimeter.jpg" width="300px"><br><br>

Ok, if your multimeter shows low resistance, we are ready to wire up your EL display.<br>

<b>Electronics:</b> To light up your EL display, you need to build the following circuit (add more information here).<br><br>

<b>Connecting the Display to the microcontroller:</b> To connect the display to the microcontroller and remaining electronics, we are going to use conductive tape. Cut a piece of conductive tape and attach it to the connector pad of the display and then to the end of a wire that goes to the microcontroller (would be great to have the break out board so this is less messy).<br><br>

<img src="images/touch-sensing-circuit.png" width="300px"><br><br>

<b>Code:</b> Once you build your circuit, you can write the code to light up your EL display (add more information here). <br><br>

    
<h4>Connecting EL Display to Processing</h4><br>

Now that you know your EL display is working properly, you can make it light up based on the information coming from the Serial communication, i.e. the beat of the song. Replace the hard coded on/off for the EL display with the '2' or '3' date you are reading from the Serial monitor. <br><br>


<h2 class="headline">Miniatiarizing the Microcontroller</h4>

Right now, we are using a pretty big and clunky microcontroller, which doesn't integrate well with our design.<br>
In the final step today, we want to replace the big microcontroller with a smaller one: the ATTiny.<br>

<img src="images/attiny.jpg" width="300px"><br><br>

Looking at this image, you may have a few questions, such as how to know which pin is which since nothing is labeled and how to program the thing since there is no space for a USB cable connection!<br><br>

<h4>Identifying Pins on the ATTiny</h4><br>

To find our which pin is which, you first need to know where is the top left corner of the Attiny. If you look very closely, you can see a small dot on the top black surface. The small dot indicates the top left corner of the controller. Once you know which corner is the top left, you can search for the <a href="https://components101.com/microcontroller/attiny85-pinout-datasheet">data sheet of the ATTiny on google</a>.<br><br>

<img src="images/attiny-top-left.png" width="200px"> <img src="images/attiny-datasheet.png" width="350px"><br><br>

Ok great, so now you know where VCC and GND are and where the data pins are for analog and digital communication.<br>
However, the question still remains, how to upload code.<br><br>

<h4>Uploading Code to ATTiny</h4><br>

There are several different ways how to program an ATTiny, one of the most straight forward is to use a device, such as the Tiny Programmer, see below.<br>

<img src="images/attiny-programmer.png" width="200px"> <br><br>

To program your ATTiny, you simply put it in the slot with the breadboard pins.<br>
In the next step, you then connect jumper wires to go from the connecting pins to your breadboard.<br>
You can use the USB connection on the Tiny Programmer to connect to your laptop.<br>

<img src="images/tiny-programmer-in-action.png" width="500px"> <br><br>

Once you confirmed that your code is correct and everything is working, you can move the ATTiny off the Tiny Programmer and put it onto your breadboard where it will keep looping its code there to perform its function.<br><br>

<h4>How to get Rid of the Breadboard? SMD Components. </h4><br>

Ok so this is already better than before, but still not great because we still have the breadboard there.<br>
So far, you have used for the ATTiny is called a DIP (dual inline package) that has two rows of pins that needly fit into a breadboard. To make it even smaller, you can get the same ATTiny as an SMD (surface mount device), which means it will not have pins but instead needs to be soldered onto a PCB.<br><br>

To produce the ATTiny as an SMD on a PCB, we used (this PCB manufacturing facility) and gave them (this specification) and (these design files). As a result, we got the following SMD component back.<br><br> 

<img src="images/attiny-smd.jpg" width="300px"> <br><br>

Ok, so now we are back at square one, how do we program the thing? Since it doesn't have pins anymore, it doesn't fit into the Tiny Programmer.<br>
Lucky for us, there is <a href="https://www.amazon.com/gp/product/B00HHH65T4/ref=ppx_yo_dt_b_asin_title_o00_s00?ie=UTF8&psc=1">another device for this</a> that you can see below.<br><br>

<img src="images/attiny-testclip.png" width="300px"> <br><br>

To use it, you clamp the front onto your ATtiny.<br>
Then you use jumper wires to connect the upper part back to the Tiny Programmer (Stefanie: I will try this out and update here once I know more).<br><br>

<img src="images/attiny-testclip2.png" width="300px"> <br><br>

<h4>Attaching the SMD Microcontroller to the rest of the Circuit with Z-Tape</h4><br>

Now that we have programmed the ATTiny PCB, we can attach it to our card.<br>
If you flip your ATTiny and look at the back you can see that we create the PCB as a double-sided PCB, i.e. the connections extend all the way to the back.<br><br>

<img src="images/attiny-front.jpg" width="300px"><img src="images/attiny-back.jpg" width="300px"> <br>
Front and back of the ATtiny PCB.<br><br>

We can now use z-tape and attach it to the back of the PCB.<br>
ztape is a special tape that conducts vertically but isolates horizontally.<br>
Once the ztape is on, you can peel back the other side of the ztape layer and attach it to your card.<br>
(Stefanie: If we want to do this part, we need to ask them to redraw their wire connections so they fit the ATTiny and not the ESP32. Perhaps this could be a good moment to use the silver pen?)<br><br> 

-->

 <h3 class="headline">Bringing it all together</h3>



 <h3 class="headline">Conclusion</h3>

Great, so now we can both read microcontroller input and display it in Processing and also use Processing to control our microcontroller. This will come in handy in the future when we want to build and test more advanced user interfaces.<br><br>

<br>

        <br />
        <br />
        <br />
      </section>

      <aside class="col-md-4 pull-left">
         <br /> <br /> <br /> <br />
<!-- 				 <h4>Pset Steps</h4><br>
				 <ul>
		 			<li><a href="#pset1">pset1 (due Sept. 21, 11.59pm): laser cut and bend the acrylic base</a><br /></li>
		 			<li><a href="#pset2">pset2 (due Oct. 5, 1pm): insert LEDs, add USB connecting and solder everything</a><br /></li>
		 			<li><a href="#pset3">pset3 (due Oct. 19, 1pm): write touch recognition so that you can determine (x,y) location of each finger</a><br /></li>
		 			<li><a href="#pset4">pset4 (due Oct. 26, 1pm): add an application of your choice</a><br /></li>
				</ul>
				<br /> <br /> <br /> <br />
        <img src="../2018-fall-6810/images/multi-touch-pad/iap1.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad/iap2.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad//iap3.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad/iap4.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad/iap5.jpg" width="220px">
 -->



        <!-- Publication -->

        <br><br><br><br><br>

        <!-- Publication -->

<!-- <h4>Side Bar</h4><br>

    <ul>
      <li>Prof. Stefanie Mueller (Instructor)</li>
      <li>Lotta-Gili Blumberg (TA)</li>
      <li>Xin Wen (UTA)</li>
      <li>Loren Maggiore (LA)</li>
      <li>Mark Chounlakone (LA)</li>
    </ul>
 -->
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>

      </aside>

    </div>
  </div>
  </div>
</section>

<div class="container">
	<div class="row">
		<div class="col-md-12 footer" style="text-align: center;">
			<span class="copyright">
			Since 2017 &copy; MIT CSAIL (HCI Engineering group) [redesign by
			<a href="http://punpongsanon.info/" target="_blank" style="text-decoration:none; border-bottom:0px">
			moji
			</a>].
			All Rights Reserved.

			<a href="http://mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/mit.svg" alt="MIT" class="footer-logo" />
			</a>
			<a href="http://csail.mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/csail.svg" alt="CSAIL" class="footer-logo"/>
			</a>
			<a href="http://hci.csail.mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/hci.svg" alt="HCI" class="footer-logo"/>
			</a>
			</span>
		</div>
	</div>
</div>

<!-- Bootstrap -->
<script type="text/javascript" src="../../js/bootstrap.min.js"></script>
<!-- header -->
<script type="text/javascript" src="../../js/headerstrap-for-subpage.js"></script>

</body>
</html>
