<!DOCTYPE html>
<html>
<head>
	<title>HCI Engineering Group</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

	<!-- CSAIL ICON -->
	<link rel="CSAIL" href="../../../images/icon/csail.ico" type="image/x-icon" />

	<!-- Bootstrap -->
	<link href="../../css/bootstrap.css" rel="stylesheet">
	<link href="../../css/custom-style.css" rel="stylesheet">

	<!-- jQuery -->
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

	<!-- Google Fonts -->
	<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Abel" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Barlow" rel="stylesheet">

	<!-- Google Analytic -->
	<script type="text/javascript" src="../../js/analytics.js"></script>

	<style>
	.etech-sch-col1 {width:60px; border: 1px solid black;padding:10px;}
	.etech-sch-col2 {width:120px; border: 1px solid black;padding:10px;}
	.etech-sch-col3 {width:450px; border: 1px solid black;padding:10px;}
	.etech-sch-col4 {width:70px; border: 1px solid black;padding:10px;}
  .etech-sch-col5 {width:70px; border: 1px solid black;padding:10px;}
  /*.etech-sch-col6 {width:170px; border: 1px solid black;padding:10px;}*/
  ul {
    padding:0px;padding-left:10px;margin:0px;
  }
	</style>
</head>

<body>
<header class="main_header">
	<!-- to be filled by javascript, see header.html -->
</header>

<section class="main_container">
	<div class="container">
    <div class="row nothing">

      <section class="col-md-8 pull-right main-content">
</br></br></br></br>
        <h4 class="medium.headline"><a href="6810-engineering-interactive-technologies.html">6.810 Engineering Interactive Technologies (fall 2020)</a><br></h>
        <h2 class="headline">Part 2: Connecting Micro-controller to UI</h2>
      
          <hr>

          <!-- Code in: Documents / Processing / SimpleRead --> 
          <!-- Code in: Documents / Arduino / serial-write -->
          <!-- Code in: Documents / Processing / SimpleWrite -->
          <!-- Code in: Documents / Arduino / serial-read -->

<h2 class="headline">Your Task for Today</h2>

You should hopefully received your package in the mail by now.</br>
The package includes your circuit design from last week and the EL displays was already in the very first package you got.<br><br>

Today, we are going to connect your last lab's card design to Processing: When you push the physical touch button it will light up the corresponding digital touch button in Processing and the corresponding song will play.<br><br>

 <h3 class="headline">Connecting the Music Card to Processing</h3>

First, we are going to read the input from our music card that you created in the last lab and display the interaction with it in Processing.<br>
In particular, we are going to wire up a button, and when the button is pressed, we will show this in Processing by coloring the corresponding button in the digital UI and starting a song.<br><br>
    
<h4>Connecting your physical music card to Processing</h4><br>

Connect your music card and ESP32 to your computer viq USB and upload the program that we haven written in the last Lab. When touching one of the sensor, your ESP should send a message to your computer that the Processing script can understand and change its background color.<br><br>

<img src="images/lab2/connect_card.jpg" width="300px"><br clear=all><br>
    
<h4>Create Processing Script that Listens to Serial Communication</h4><br>
    
<a href="https://processing.org" target="_blank">Processing</a> is a user interface protoyping platform that is based on Java. It was created by MIT students (and others) in their spare time starting in Spring 2001 and is nowadays used by thousands of makers and UI designers. You can find useful information on how to use it in their <a href="https://processing.org/tutorials/" target="_blank">tutorial section</a>.<br><br>

In the last lab, we encoded a touch event on the printed UI in the format:<br><br>
(sensor ID),(is_touched);<br><br>
    
(sensor ID) is in [0..2] and represents the ID of the observed touch sensor<br>
(is_touched) is in [0..1] and is 0 if the sensor is not touched, and 1 if it is touched<br><br>

Now that we are writing Serial message depending on whether the button is pressed or not pressed, we can write the Processing script that listens to the Serial communication and changes its visualization depending on the number read.<br><br>

To do this, open Processing and import the <a href="https://processing.org/reference/libraries/serial/index.html">Serial library</a>.<br>
<pre>import processing.serial.*;</pre><br><br>

Next, you need to create a new port by creating an object from this class: <br>
<pre>Serial myPort;</pre><br><br>

To initialize this object, you need a reference to the current application ('this'), a portname, and the baudrate to which the object should listen. You already know the baudrate and you can get the portname with this:<br><br>

<pre>myPort = new Serial(this, portName, 9600);</pre><br><br>
    
Now you can initialize your Serial connection:<br><br>
    
<pre>// check which port you use: 0, 1, 2?
// it helps to verify you are listening to the right port with print(portName);
String portName = Serial.list()[2];</pre><br><br>

In the draw function, you need to first check if there is data on the port available, and then you can read the value from the port.<br><br>

<pre>int val;
if ( myPort.available() > 4) { // If there is a message with at least 4 characters,
    String val = myPort.readStringUntil(';'); // reads a String until the character ';' is found
  }</pre>

Now you can do something based on the String.<br><br>
    
In the last lab, we encoded a touch event on the printed UI in the format:<br><br>
(sensor ID),(is_touched);<br><br>

Your task is to visualize the incoming serial messages in a Processing Script. We will see 3 bars that go up and down if one or multiple of the physical buttons get touched. It should look like this:<br><br>
    
<img src="images/lab2/processing_bars.png" width="300px"><br clear=all><br>
    
We created a Processing script for you that has the bars already implemented but lacks the Serial Communication.<br>
You can download the script here: <a href="images/lab2/Serial_Processing.zip">SCRIPT</a><br><br>
    
Your task is to add the Serial communcation that receives the touch signal from your printed touch sensors and show their state with the 3 bars, i.e. a high bars shows that the sensor is touched and a low bar shows that the sensor is not touched. You can use the 3 boolean variables touch_0, touch_1, and touch_2 in the script to this end. <br><br>
    
<h4>Connecting your physical music card to Processing</h4><br>

Connect your music card and Arduino Nano to your computer and upload the program that we haven written in the last Lab. When touching one off the sensor, your Arduino should send a message to your computer that the Processing script can understand and change its background color.
    
<br>
<div style="background:#04a47c;padding:10px;">Checkoff 1: Show your working physical button that when pushed causes the Processing application to change its background color.</div><br><br>
<!--
<h4>Replacing the Standard Button with your Printed Touch Button</h4><br>

We hope you received your custom touch button from last week. If not, your original package has a standard printed touch button (square) that you can use instead.<br><br>

We are now going to replace the standard touch button with your custom touch button.<br>
First, use the multimeter to check if you touch button is conductive and didn't break during transport.<br>
If you don't remember how to use the multimeter, check last week's tutorial.<br><br>

<img src="images/multimeter.jpg" width="300px"><br><br>

Ok, if your multimeter shows low resistance, we are ready to wire up your touch button.<br>

<b>Electronics:</b> To build the circuit to implement touch sensing you only need your touch sensor and one resistor (say some more why this is necessary). Low resistors (1kOhm - 100kOhm) are mostly used for sensing touch (see Figure below).<br><br>

<img src="images/touch-sensing-principle.png" width="300px"> <img src="images/touch-sensing-circuit.png" width="300px"><br><br>

<img src="images/touch-sensor-on-breadboard.jpg" width="300px"> <img src="images/touch-sensor-on-breadboard-schematic.png" width="300px"><br><br>

<b>Connecting the Touchbutton to the microcontroller:</b> To connect the touch button to the microcontroller and remaining electronics, we are going to use conductive tape. Cut a piece of conductive tape and attach it to the connector pad and then to the end of a wire that goes to the microcontroller (would be great to have the break out board so this is less messy).<br><br>

<b>Code:</b> Once you build your circuit, you can write the code to read input from your touch sensor. Capacitive touch sensing is luckily already supported by the Arduino Toolkit.<br><br>

Download the latest <a href="https://github.com/PaulStoffregen/CapacitiveSensor"> library CapacitiveSensor for Arduino from here</a> and place it into your Documents / Arduino / Libraries folder (unzip it and rename it to 'CapacitiveSensor'). Restart your Arduino software, otherwise the library is not recognized.<br><br>

First you need to import the library:<br>  
<code>#include CapacitiveSensor.h</code><br>  <br>  

Next, you need to create a new CapacitiveSensor object:<br>  
<code>CapacitiveSensor sensor1 = CapacitiveSensor(sender, touch_pin_1);</code><br>  
It takes as input the pin that has the high signal and the receiver pin.<br><br>  

In the loop function, you are now ready to read from the sensor.<br>  <br>  

<code>double analog_touch = sensor1.capacitiveSensor(samples_touch);</code><br>  
The argument <b>samples</b> defines the sensitivity of the sensor.<br>  <br>  
For touch sensing a low sensitivity is common with samples between 1 and 20. <br><br>

If you print analog_touch to the Serial monitor and you touch your touch button, you should be able to see the values change quite drastically. Do some simple thresholding to determine when the button is pushed and when it is not pushed (e.g., values above XX equal pushed, values below XX equal unpushed). <br><br> 

<div style="background:#04a47c;padding:10px;">Checkoff 2: Show your working touch sensor that when pushed, prints 'pushed' to the Serial monitor and otherwise prints 'unpushed'.</div><br>

 <h3 class="headline">Performing Input in Processing<br> and Using it on the Microcontroller</h3>

Let's do it the other way around and write some output from Processing onto the microcontroller.<br>
In our simple example, we will light up an LED when the user clicks a button in the Processing UI, and then later replace it with our printed EL display.<br><br>

<h4>Wiring Up an LED and Write Basic On/Off Code</h4>

Let's start by wiring up an LED on the breadboard and writing the basic code to turn the LED on/off. <br>
If you haven't coded in Arduino for a while, you may want to look at 'Examples -> Blink' to see how to read input from a pin and turn your LED on/off.<br><br>

<img src="images/led-on-breadboard.jpg" width="250px"> <img src="images/led-on-breadboard-schematic.png" width="350px"><br><br>

<h4>Create Microcontroller Script that Reads from Serial Monitor</h4>

Once you confirmed that your LED works (i.e. you tested it turns on), we will now write a piece of Arduino code that will listen to the Serial communication and whenever it encounters a '2' it will light up the LED and when it encounters a '3' it will turn the LED off.<br><br> 

This part is very similar to the previous Arduino code, just that instead of Serial.write() you are now going to use <a href="https://www.arduino.cc/reference/en/language/functions/communication/serial/read">Serial.read()</a> to determine if a 2 or 3 was send and the LED should be on or off.<br><br>

Complete the rest of the Arduino script for turning on/off your LED by reading from the Serial connection and upload it to the microcontroller.<br>
We will test this in a moment when we connect it to Processing.<br><br>

<h4>Create Processing Script that Writes to Serial Monitor</h4>

Once you uploaded your Arduino code, we are now ready to write a Processing script to write to the serial connection the '2' or '3' values, which can then be used by the Arduino code to decide if the LED should be on or off.<br>
Whenever a button is clicked in the Processing UI, we want to write a '2', otherwise a '3'. <br><br>

The setup code is the same as in the previous Processing example above, but now you are using<br>
<code>myPort.write(2); // 2 or 3 depending on state</code><br><br>

        <!--
    
<h4>Blinking LED to Beat</h4><br>

To blink the LED to the beat, we prepared this custom Processing script for you.<br>
All you need to do is to send a '2' or '3' whenever our script tells us that the beat just happened.<br>

<div style="background:#04a47c;padding:10px;">Checkoff 3: Show your working LED that can be turned on by pushing the button in Processing and can also blink to the beat of a song.</div><br><br>

<h4>Replacing the Standard LED with your Printed Display</h4><br>

With that information in mind, we are now ready to connect your EL display to the microcontroller.<br>
First, use the multimeter to check if your display is conductive and didn't break during transport.<br>

<img src="images/multimeter.jpg" width="300px"><br><br>

Ok, if your multimeter shows low resistance, we are ready to wire up your EL display.<br>

<b>Electronics:</b> To light up your EL display, you need to build the following circuit (add more information here).<br><br>

<b>Connecting the Display to the microcontroller:</b> To connect the display to the microcontroller and remaining electronics, we are going to use conductive tape. Cut a piece of conductive tape and attach it to the connector pad of the display and then to the end of a wire that goes to the microcontroller (would be great to have the break out board so this is less messy).<br><br>

<img src="images/touch-sensing-circuit.png" width="300px"><br><br>

<b>Code:</b> Once you build your circuit, you can write the code to light up your EL display (add more information here). <br><br>

    
<h4>Connecting EL Display to Processing</h4><br>

Now that you know your EL display is working properly, you can make it light up based on the information coming from the Serial communication, i.e. the beat of the song. Replace the hard coded on/off for the EL display with the '2' or '3' date you are reading from the Serial monitor. <br><br>


<h2 class="headline">Miniatiarizing the Microcontroller</h4>

Right now, we are using a pretty big and clunky microcontroller, which doesn't integrate well with our design.<br>
In the final step today, we want to replace the big microcontroller with a smaller one: the ATTiny.<br>

<img src="images/attiny.jpg" width="300px"><br><br>

Looking at this image, you may have a few questions, such as how to know which pin is which since nothing is labeled and how to program the thing since there is no space for a USB cable connection!<br><br>

<h4>Identifying Pins on the ATTiny</h4><br>

To find our which pin is which, you first need to know where is the top left corner of the Attiny. If you look very closely, you can see a small dot on the top black surface. The small dot indicates the top left corner of the controller. Once you know which corner is the top left, you can search for the <a href="https://components101.com/microcontroller/attiny85-pinout-datasheet">data sheet of the ATTiny on google</a>.<br><br>

<img src="images/attiny-top-left.png" width="200px"> <img src="images/attiny-datasheet.png" width="350px"><br><br>

Ok great, so now you know where VCC and GND are and where the data pins are for analog and digital communication.<br>
However, the question still remains, how to upload code.<br><br>

<h4>Uploading Code to ATTiny</h4><br>

There are several different ways how to program an ATTiny, one of the most straight forward is to use a device, such as the Tiny Programmer, see below.<br>

<img src="images/attiny-programmer.png" width="200px"> <br><br>

To program your ATTiny, you simply put it in the slot with the breadboard pins.<br>
In the next step, you then connect jumper wires to go from the connecting pins to your breadboard.<br>
You can use the USB connection on the Tiny Programmer to connect to your laptop.<br>

<img src="images/tiny-programmer-in-action.png" width="500px"> <br><br>

Once you confirmed that your code is correct and everything is working, you can move the ATTiny off the Tiny Programmer and put it onto your breadboard where it will keep looping its code there to perform its function.<br><br>

<h4>How to get Rid of the Breadboard? SMD Components. </h4><br>

Ok so this is already better than before, but still not great because we still have the breadboard there.<br>
So far, you have used for the ATTiny is called a DIP (dual inline package) that has two rows of pins that needly fit into a breadboard. To make it even smaller, you can get the same ATTiny as an SMD (surface mount device), which means it will not have pins but instead needs to be soldered onto a PCB.<br><br>

To produce the ATTiny as an SMD on a PCB, we used (this PCB manufacturing facility) and gave them (this specification) and (these design files). As a result, we got the following SMD component back.<br><br> 

<img src="images/attiny-smd.jpg" width="300px"> <br><br>

Ok, so now we are back at square one, how do we program the thing? Since it doesn't have pins anymore, it doesn't fit into the Tiny Programmer.<br>
Lucky for us, there is <a href="https://www.amazon.com/gp/product/B00HHH65T4/ref=ppx_yo_dt_b_asin_title_o00_s00?ie=UTF8&psc=1">another device for this</a> that you can see below.<br><br>

<img src="images/attiny-testclip.png" width="300px"> <br><br>

To use it, you clamp the front onto your ATtiny.<br>
Then you use jumper wires to connect the upper part back to the Tiny Programmer (Stefanie: I will try this out and update here once I know more).<br><br>

<img src="images/attiny-testclip2.png" width="300px"> <br><br>

<h4>Attaching the SMD Microcontroller to the rest of the Circuit with Z-Tape</h4><br>

Now that we have programmed the ATTiny PCB, we can attach it to our card.<br>
If you flip your ATTiny and look at the back you can see that we create the PCB as a double-sided PCB, i.e. the connections extend all the way to the back.<br><br>

<img src="images/attiny-front.jpg" width="300px"><img src="images/attiny-back.jpg" width="300px"> <br>
Front and back of the ATtiny PCB.<br><br>

We can now use z-tape and attach it to the back of the PCB.<br>
ztape is a special tape that conducts vertically but isolates horizontally.<br>
Once the ztape is on, you can peel back the other side of the ztape layer and attach it to your card.<br>
(Stefanie: If we want to do this part, we need to ask them to redraw their wire connections so they fit the ATTiny and not the ESP32. Perhaps this could be a good moment to use the silver pen?)<br><br> 

-->

 <h3 class="headline">Bringing it all together</h3>

Now extend your code to include the three different touch buttons, i.e. each button should play a different song.<br><br>

<div style="background:#04a47c;padding:10px;">Checkoff 4: Show your final card that has three different working buttons that each play a different song and an EL display that lights up with the beat.</div><br>

 <h3 class="headline">Conclusion</h3>

Great, so now we can both read microcontroller input and display it in Processing and also use Processing to control our microcontroller. This will come in handy in the future when we want to build and test more advanced user interfaces.<br><br>

<br>

        <br />
        <br />
        <br />
      </section>

      <aside class="col-md-4 pull-left">
         <br /> <br /> <br /> <br />
<!-- 				 <h4>Pset Steps</h4><br>
				 <ul>
		 			<li><a href="#pset1">pset1 (due Sept. 21, 11.59pm): laser cut and bend the acrylic base</a><br /></li>
		 			<li><a href="#pset2">pset2 (due Oct. 5, 1pm): insert LEDs, add USB connecting and solder everything</a><br /></li>
		 			<li><a href="#pset3">pset3 (due Oct. 19, 1pm): write touch recognition so that you can determine (x,y) location of each finger</a><br /></li>
		 			<li><a href="#pset4">pset4 (due Oct. 26, 1pm): add an application of your choice</a><br /></li>
				</ul>
				<br /> <br /> <br /> <br />
        <img src="../2018-fall-6810/images/multi-touch-pad/iap1.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad/iap2.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad//iap3.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad/iap4.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad/iap5.jpg" width="220px">
 -->



        <!-- Publication -->

        <br><br><br><br><br>

        <!-- Publication -->

<!-- <h4>Side Bar</h4><br>

    <ul>
      <li>Prof. Stefanie Mueller (Instructor)</li>
      <li>Lotta-Gili Blumberg (TA)</li>
      <li>Xin Wen (UTA)</li>
      <li>Loren Maggiore (LA)</li>
      <li>Mark Chounlakone (LA)</li>
    </ul>
 -->
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>

      </aside>

    </div>
  </div>
  </div>
</section>

<div class="container">
	<div class="row">
		<div class="col-md-12 footer" style="text-align: center;">
			<span class="copyright">
			Since 2017 &copy; MIT CSAIL (HCI Engineering group) [redesign by
			<a href="http://punpongsanon.info/" target="_blank" style="text-decoration:none; border-bottom:0px">
			moji
			</a>].
			All Rights Reserved.

			<a href="http://mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/mit.svg" alt="MIT" class="footer-logo" />
			</a>
			<a href="http://csail.mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/csail.svg" alt="CSAIL" class="footer-logo"/>
			</a>
			<a href="http://hci.csail.mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/hci.svg" alt="HCI" class="footer-logo"/>
			</a>
			</span>
		</div>
	</div>
</div>

<!-- Bootstrap -->
<script type="text/javascript" src="../../js/bootstrap.min.js"></script>
<!-- header -->
<script type="text/javascript" src="../../js/headerstrap-for-subpage.js"></script>

</body>
</html>
