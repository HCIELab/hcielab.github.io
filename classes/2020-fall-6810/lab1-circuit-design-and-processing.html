<!DOCTYPE html>
<html>
<head>
	<title>HCI Engineering Group</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

	<!-- CSAIL ICON -->
	<link rel="CSAIL" href="../../../images/icon/csail.ico" type="image/x-icon" />

	<!-- Bootstrap -->
	<link href="../../css/bootstrap.css" rel="stylesheet">
	<link href="../../css/custom-style.css" rel="stylesheet">

	<!-- jQuery -->
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

	<!-- Google Fonts -->
	<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Abel" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Barlow" rel="stylesheet">

	<!-- Google Analytic -->
	<script type="text/javascript" src="../../js/analytics.js"></script>

	<style>
	.etech-sch-col1 {width:60px; border: 1px solid black;padding:10px;}
	.etech-sch-col2 {width:120px; border: 1px solid black;padding:10px;}
	.etech-sch-col3 {width:450px; border: 1px solid black;padding:10px;}
	.etech-sch-col4 {width:70px; border: 1px solid black;padding:10px;}
  .etech-sch-col5 {width:70px; border: 1px solid black;padding:10px;}
  /*.etech-sch-col6 {width:170px; border: 1px solid black;padding:10px;}*/
  ul {
    padding:0px;padding-left:10px;margin:0px;
  }
	</style>
</head>

<body>
<header class="main_header">
	<!-- to be filled by javascript, see header.html -->
</header>

<section class="main_container">
	<div class="container">
    <div class="row nothing">

      <section class="col-md-8 pull-right main-content">
</br></br></br></br>
        <h4 class="medium.headline"><a href="6810-engineering-interactive-technologies.html">6.810 Engineering Interactive Technologies (fall 2020)</a><br></h>
        <h2 class="headline">Inkjet Printed Sensors and Introduction to Processing</h2>

  <!-- <img src="images/silver-printing.jpg" width="317px" /> -->
          <br>


<!-- <h2 class="headline">Interactive Music Card</h2> -->

In lab 1 and lab 2, we are going to create the interactive music card shown below. Underneath the visual design, the music card has an inkjet printed circuit with touch buttons and sliders that allow the user to play songs and control the volume. The card is connected to a microcontroller for analyzing user input and then sends the signals to a program called Processing for visualizing user input on screen.<br><br>
<!-- 
<img src="images/music-card1.png" width="200px" />
<img src="images/music-card2.png" width="200px" />
<img src="images/music-card3.png" width="200px" />
 -->
<img src="images/music-card-design.png" width="285px" />
<img src="images/lab1-design-planning_new.png" width="275" />
<img src="images/lab1-print3.jpg" width="155px" />


<h2 class="headline">Your Task for Today: Circuit Design and Signal Processing</h2>

<b>(1) Circuit Design:</b> You will first draw the circuit design of your card by creating a 2D drawing of the wires and interactive touch and slider areas.<br>
<b>(2) Conductive Silver Inkjet Printing:</b> Next, you will print your design with conductive inkjet printing.<br>
<b>(3) Wiring up the Buttons:</b> In the next step, you will wire up your touch buttons using a breadboard and an ESP32 microcontroller.<br>
<b>(4) Sensing the Touch Signals:</b> Next, you will sense the touch signals using capacitive touch sensing (through Arduino's CapacitiveSensor Library) and apply filtering to the signals.<br>
<b>(5) (next lab, not today) Visualizing User Input:</b> We will then setup the touch buttons and sliders in a programming environment called Processing, which will visualize on screen when someone touches the touch buttons and sliders and will also play the corresponding songs from the music card. <br>
<b>(6) (next lab, not today) Wiring up and Visualizing the Slider:</b> Finally, you will add the slider to your circuit and user interface and use it to control the music volume.<br>

<h2 class="headline">Deliverables Lab 1 (due Friday, Sept. 11, 2020, 11.59pm)</h2>

At the end of Lab 1, upload to your student google drive:
<ul>
	<li>the circuit drawing (.pdf file format) you used for conductive inkjet printing</li>
	<li>the Arduino code you wrote for Serial Communication (.ino file format)</li>
</ul><br>

<hr>

<h2 class="headline">(1) Circuit Design</h2>

<h4>Download and Open Visual Design File</h4>
To get started, download the visual design of our music card <a href="images/lab1-music-card-final-size.pdf">here.</a><br><br>

<h4>Where to Add the Touch Button and Slider</h4>

For our interactive card, we want to add three touch buttons, one on each note (we will later use them to go to the next/previous song and pause/play the song).<br>
In addition, the piano area should serve as a volume slider, i.e. if we drag our finger from left to right, the volume of the music that is playing will increase.<br><br>

<img src="images/music-card-design.png" width="350px" />
<img src="images/lab1-design-planning_new.png" width="335px" /><br><br>

<h4>Draw the Touch Buttons and Their Wires</h4><br>

Touch-buttons consist of one shape + one wire.<br>
One end of the wire connects to the touch button shape and the other end connects to a connector pad, which will in turn connect to the microcontroller.<br><br>

<!-- <img src="images/touch-button-decorative1.png" width="300px"><br><br> -->
<img src="images/lab1-single-touch-button_new.png" width="400px"><br><br>

We can later sense the user's touch using a principle called <b>capacitive touch sensing</b>, which as discussed in lecture requires only one electrode (i.e. the touch button) and the other electrode is your finger.<br> Below is the image from lecture as a reminder of how this works.<br><br>

<img src="images/lab1-touch-example-lecture.png" width="600px"><br><br>


With your drawing program open, let's draw the touch buttons and their wires for each of the three notes. <br>
While drawing, make sure you follow the specifications, which are:<br><br>

<b>Set Document Color Mode to CMYK:</b> Since we will print our document later, please set the document color mode to CMYK (not RGB, which is for on-screen documents).<br><br>

<b>Set Units to mm:</b> If your drawing is still set to 'pts' as a measurement unit, set it to mm or inch.<br><br>

<b>Color of Lines/Shapes:</b> <span style="color:red">The color for all your circuit design should be set to black (CMYK: 0,0,0,255) since we will use the 'K' cartridge for printing the silver ink.</span><br><br>

<b>Create a New Layer:</b> Make sure your circuit design is on a new separate layer than the existing visual design. Later we need to export two files seperately, the visual design in one pdf and the circuit design in a seperate pdf. Using a seperate layer for each allows you to turn each part of the design on/off quickly for export.<br><br>

<b>Area of Touch Button:</b> A touch button should be large enough for a user's finger (size of a finger tip is an area around 2cm x 2cm). In the design we gave you, the size of each note body is roughly the size of a finger pad, so as long as you trace the note it should be fine.<br><br>

<b>Thickness of Wires:</b> Your wires should be 1mm thick. Make sure to check this in your drawing program. We typically draw 'rectangles' for the wires rather than 'lines' since a rectangle allows us to see its 'width' in the shape properties. The thickness of the wire determines its conductivity (larger cross-section = hire conductivity), with 1mm we are on the safe side given the conductive ink we use and its resistance.<br><br>

<b>Connector Pads for Wires:</b> One end of your wire connects to your touch button. The other end of your wire will connect to a connector pad which we will later use to connect to the ESP microcontroller. The connector pad for the microcontroller needs to be large enough to connect to a crocodile clamp. The connector pad should be 1cm x 1cm to be on the safe side. We recommend you route all your wires to the right side of the card and we will connect the microcontroller there. Make sure your connector pads are close enough to the border so that a crocodile clamp can reach it (see image below).<br><br>

<!-- Make sure your connector pads are as close to the boundary of the card as possible. We will later connect them to crocodile clamps for connecting to the circuit, if they are too far away the crocodile clamps cannot reach them (left image below is not good, right side is better). -->

Left: connector pad not close enough to border, crocodile clamp can barely reach it. Right side: better.<br>
<img src="images/lab1-crocodile-clamps1.jpg" width="300px">
<img src="images/lab1-crocodile-clamps2.jpg" width="300px"><br><br>


<h4>Draw the Touch Slider and the Corresponding Wires</h4><br>

Great, now that you have the three touch buttons of the notes connected, we can move on and draw the circuit for the slider.<br>
Touch-sliders consist of multiple touch buttons linearly arranged, i.e. several segments and each segment has its own wire that connects to the micro-controller.<br><br>

<b>Discrete vs. Continous Sliders:</b><br>

In the discrete slider design, the finger tends to be only over one of the slider segments. <br>
In the continous design, the finger tends to touch two adjacent slider segments. By knowing how much the finger touches each slider segment, we can extrapolate a continous transitions between the segments.<br><br>

<img src="images/slider-designs1.png" width="300px"><br>
From the paper <a href="https://dl.acm.org/doi/10.1145/2971763.2971777">DuoSkin (ISWC 2016)</a><br><br>

<b>Type of Slider:</b> We will create a continuous slider, i.e. the segments overlap.<br><br>

<b>Number of Slider Segments:</b> We will create five slider segments that make up the slider. More slider segments allow for higher resolution, but also need more space for wiring, connector pads, and more input pins on the microcontroller. Below you see an image that already has two slider segments marked up, you need to divide the remaining 'piano' area to form another three slider segments and connect them via wires to some additional connector pads. When you draw your slider segments, pay close attention that each slider segment overlaps with each oder, i.e. you can see how the front of the first segment reaches deep into the second segment to maximize overlap.<br><br>

<b>Line Width, Connector Pad etc.:</b> You need to follow the same specification as above, i.e. use the same wire thickness (1mm) and the same connector pad size (1cm x 1cm).<br><br>


<img src="images/lab1-slider-segments_new.png" width="350px">
<img src="images/lab1-slider-overlap-labeled.png" width="370px"><br><br>


<h4>Check your Design Before Printing</h4><br>

Before printing, <span style="color:red">double check that all your circuit lines are pure black, i.e. CMY = 0 and K = 100.</span><br><br>

<img src="images/lab1-cmyk.png" width="250px"><br><br>

Also double check that your design has two separate layers:<br>
<b>Layer 1:</b> visual design<br>
<b>Layer 2:</b> circuit design<br><br>

You need to be able to turn them on/off individually since we will print the circuit in a first pass, then reinsert the paper and then print the visual design on the other side of the paper. Printing on the same side of paper does not work since the visual ink is not able to cover up the silver. Also for capacitive touch sensing, we never want to touch the silver directly, so it is better to flip the paper and interact on the other side where the visual design was printed.<br><br>

In order to accommodate the double-side printing, we will need to mirror one of the two layers otherwise if we flip the sheet for printing the second pass things will not align. To do this, first make sure that you place both the visual and circuit design at the <b>center of sheet</b>. Since mirroring the visual design would look weird, we will mirror the circuit design since it will be on the backside of the card after printing and thus doesn't impact the design. In Adobe Illustrator, to mirror the design, we will first select all objects in the circuit design layer, then go to <b> Object --> Transform --> Reflect... </b>, and select <b> Vertical</b>. If you use a different drawing program, please google to find out how to mirror your design.<br><br>

<img src="images/lab1-mirror-circuit-design.png" width="720px" /><br><br>

After mirroring, you should have something that looks like below.<br> 
Then you can go ahead and print them out one by one.<br><br>

Left: Before mirroring, not ready to print. Right: After mirroring the circuit design, ready for printing!<br>
<img src="images/lab1-circuit-center-mirror.png" width="720px" /><br><br>

Once you have your design, add it to your student google drive folder as three pdfs (combined-visual-circuit.pdf with both layers, visual-design.pdf separate and circuit-design.pdf separate) and let us know on slack that you are ready to have your design checked by us.<br><br>

Once you have our ok, <a href="https://docs.google.com/spreadsheets/d/1D5WDSVnoo7_nljYBE96kVc2roTcheib4fP57s_PL0Ho/edit?usp=sharing">please book an OH slot and come in to print</a>.<br>
You can either print from your own laptop or use the computer we have in the workshop.<br>

If you want to print from your own laptop, please make sure you install the printer driver for the <span style="color:red"><a href="https://www.usa.canon.com/internet/portal/us/home/support/details/printers/mobile-compact-printer/pixma-tr150">Canon PIXMA TR150 Printer</a></span> and a second printer driver for the <a href="https://epson.com/Support/Printers/All-In-Ones/ET-Series/Epson-ET-2760/s/SPT_C11CG22203">Epson EcoTank ET-2760.</a><br><br>

<img src="images/music-card-design.png" width="317px" />
<img src="images/lab1-exporting-design-circuit_new.png" width="317px" /><br><br>

<h2 class="headline">(2) Conductive Silver Inkjet Printing</h2>

Theoretically, we can use a single printer to print both the circuit design and the visual design.<br>
Since 2D printers have two cartridges, i.e. a CMY cartridge for color printing and a K-cartridge for black, we can simply empty the K-catridge and fill it with silver ink.<br>
So anything in your drawing that is 'K' (pure black) will be printed in silver and the rest will be printed from the regular CMY cartridge.<br><br>

<img src="images/lab1-printing-explained.png" width="437px" />
<img src="images/lab1-silver-inkjet-printer-cartridge.jpg" width="267px" /><br><br>

For our class, however, we are using two 2D inkjet printers, one for the circuit printing and one for the visual design.<br>
<span style="color:red">The reason for this is that the printer drivers of our inkjet printers do not support printing 'with only the CMY cartridge' (Stefanie: do you mean with only 'K'?), they will always use the K-cartridge (Stefanie: CMY?) as well for part of the print.</span><br>
Therefore, we use two printers: In one printer, we use the CMY cartridge as original intended for color printing. In the other printer, we empty the CMY cartridge and replace it with silver ink. The "K" (Black) cartridge remains in its original form, i.e. contains black ink. <br><br> 

<h4>Buying Materials and Preparing the Printer</h4><br>

While we have already done this for you, we provide you here with the details in case you want to try this yourself in the future:<br><br>

<b>2D Printer:</b> For the class, we are using the <a href="https://www.amazon.com/Canon-TR150-Wireless-Airprint-Compatible/dp/B085VMW9YD">Canon PIXMA TR150 Printer</a> for the silver inkjet printing, and the <a href="https://www.officedepot.com/a/products/5969402/Epson-Expression-ET-2760-EcoTank-Wireless/?cm_mmc=Affiliates-_-CJ-_-1634220-_-11553109">Epson EcoTank ET-2760 All-in-One Supertank Printer</a> for normal color printing. Both printers work for silver inkjet printing (other 2D printers may work as well but it depends on their nozzle diameter and print head type, i.e. the silver may clogg them if they are too small. Also note that the print head should be a piezoelectric print head.<br><br>

<b>Silver Ink:</b> We bought cartridges for Canon PIXMA TR150 (same cartridges as Canon PIXMA IP110) <a href="https://www.amazon.com/gp/product/B015YALJ0U/ref=ppx_yo_dt_b_search_asin_title?ie=UTF8&psc=1"> from here</a>, and separately bought silver ink from <a href="http://www.mitsubishiimaging.com/digital-imaging-diamond-jet-NANOINK.html"> Mitsubishi</a>. Before filling the silver ink, we cut open the cartridge, washed it clean, dried it up, then re-assembled it back. If you want to use the Epson EcoTank ET-2760 Printer for silver ink printing, you don't need additional cartridges, and you can directly fill the silver ink into its build-in cartridges. <!-- <span style="color:red">from here (add link).</span> --><br><br>

<b>Syringe:</b> To fill the silver into the cartridge, you need a syringe. We bought syringes from <a href="https://www.amazon.com/5ml-Oral-Syringes-Individually-Administration/dp/B07GX34NBV/ref=pd_bxgy_img_3/131-4743964-2993361?_encoding=UTF8&pd_rd_i=B07GX34NBV&pd_rd_r=7f8c8270-6e29-404c-8aba-640c11b3923e&pd_rd_w=XPpPv&pd_rd_wg=85mK1&pf_rd_p=ce6c479b-ef53-49a6-845b-bbbf35c28dd3&pf_rd_r=X526NNSME57D10CNY14E&psc=1&refRID=X526NNSME57D10CNY14E">here</a><br><br>

<b>Paper:</b> With the silver ink we use, we cannot print on any paper but need a special sheet, which chemically sinters the silver ink once it adheres to the sheet. We use the following sheets: <a href="http://www.mitsubishiimaging.com/digital-imaging-diamond-jet-NANOINK.html"> Mitsubishi PET films</a> and <a href="https://www.amazon.com/Kodak-8209017-KOD8209017-Photo-Paper/dp/B000EZ0CTU"> Kodak glossy photo paper</a>. <!-- <span style="color:red">from here (add link)</span> --><br><br>

<b>Drying out:</b> Note that if the silver is too long in the cartridge, it will eventually dry out and not print anymore.<br><br>

<!-- <h4>Printing your Design in Two Passes</h4><br>

As mentioned before, we will be printing the design files on <b>2 sides of the same photo paper sheet</b>.<br><br>
 --><!-- 
<span style="color:red">update this part based on using two different printers</span>
While we can use the same printer for both visual and circuit design, we cannot print color (CMY) and silver (K) at the same time (same pass).<br>
The reason is that in order to 'force' the printer to use the 'K' cartridge, we need to select 'grayscale' in the printer driver and that naturally doesn't allow for color.<br> On the contrary, in order to 'force' the printer to use the 'CMY' cartridge, we select 'full color' printing (this does not use the 'K' cartridge).<br><br> 

Since we can only select either grayscale or color printing, we need to do two seperate passes, i.e. we first print the circuit in silver, take the paper out, reinsert, and then print the color for the visual design.<br><br> -->


<h4>Print Settings for Printing Silver</h4><br>

As mentioned before, we will be printing the design files on <b>2 sides of the same photo paper sheet</b>.<br>
We will start with printing the silver.<br><br>

If you want to print from your own laptop, please make sure you install the printer driver for the <span style="color:red"><a href="https://www.usa.canon.com/internet/portal/us/home/support/details/printers/mobile-compact-printer/pixma-tr150">Canon PIXMA TR150 Printer</a></span> (for silver) installed.<br><br>

Plug in the Canon Pixma printer and open your Circuit Design File.<br><br>

Go to print, and from the 'Printer' dropdown select the 'Canon iP110 series'.<br><br>
<img src="images/lab1-printer.png" width="517px" /><br><br>

Next, click 'setup' (bottom left corner), then 'continue'.<br><br>

<img src="images/settings2.png" width="517px" /><br><br>

Go to 'Quality and Media' in the dropdown, then select 'Media Type' and 'Photo paper' and 'Photo Paper Plus Glossy 2'.<br>
Whenever we select the 'Glossy Paper' setting, the printer will automatically only use the CMY cartridge and will not use the K cartridge, which is exactly what we want.<br>
<img src="images/settings3.png" width="517px" /><br><br>

Then go to 'Print Quality' and select 'Custom' and put the resolution to the highest 'Fine' setting.<br><br>

<img src="images/settings4.png" width="517px" />
<img src="images/settings5.png" width="517px" /><br><br>

<!-- Don't forget to click the checkbox for 'Grayscale' Printing, since we want to use the 'K' cartridge, which has the silver loaded.<br><br>

<img src="images/settings6.png" width="517px" /><br><br> -->

Next, insert the paper.<br>
The paper has two sides, a sticky side and a non-sticky side.<br>
The sticky side should be facing up.<br>
If you are not sure which side is which, you can lick your finger and touch each side of the paper in the corner. The sticky side will have a white shine and the other side will show nothing. So the white shiny side should be facing up.<br>

<img src="images/lab1-insert-paper.jpg" width="337px" />
<img src="images/lab1-insert-paper-test.jpg" width="307px" /><br><br>

Now you are ready to hit the print button. <br><br>

<img src="images/lab1-print1.jpg" width="437px" />
<!-- <img src="images/lab1-print2.jpg" width="337px" /> -->
<img src="images/lab1-print3.jpg" width="237px" /><br><br>

The newly printed silver ink sometimes can be scraped off by your finger if you got sweaty hands, this is because the silver ink has not been fully cured and it would not be an issue after a few hours. In order to prevent that, we recommand that you handle the newly printed silver circuits with the powder free disposable gloves on (we will give you some when you come in for printing). We will also provide you with one ZipLoc bag to put your printed silver circuit in so that it does not get scraped off during transportation. <br><br>


<h4>Test with a Multi-Meter if your Silver Print is Conductive</h4><br>

Before we print the color layer, let's first check if the silver layer is conductive or if anything went wrong during the print.<br>
Sometimes print nozzles clog and then some silver particles cannot exit through the nozzle, which leaves small gaps in your printed area, which reduce conductivity.<br><br>

The print is successful, i.e. highly conductive and resistance low, if silver was deposited over the entire area.<br>
The print was unsucessful if there are many tiny gaps, i.e. conductance will be low and resistance high.<br><br>

Resistance is also influenced by the length of the wire and its thickness as mentioned above.
A thicker wire allows the current to flow better and thus leads to higher conductivity.<br>
A longer trace accumulates resistance on its path therefore has lower conductivity (higher resistance).<br> <br> 

To check the resistance, we can use a Digital multimeter (DMM).<br><br>

To use the multi-meter, first set it to 'resistance' mode.<br><br>

<img src="images/lab1-multimeter1.jpg" width="300px"><br><br>  

Next, set the sensitivity to the highest by pressing the 'range' button a bunch of times until the dot is at the front.<br><br>  

<img src="images/lab1-multimeter2.jpg" width="300px"><br><br>  

Next, hold the two measurement points at the beginning and end of a wire to measure the resistance along the trace.<br><br>

<img src="images/lab1-multimeter3.jpg" width="300px"><br><br>  

Here we have a fantastically low resistance of 1ohm. <br>
If you see a 'OL' message in the display, your trace is broken and the resistance was so high it couldn't be displayed because it was out of range. <br>
If that happens to you, let us know and we will print your design again.<br><br>

<h4>Print Settings for Printing Color</h4><br>

Plug in the Epson EcoTank ET-2760 printer (used for visual design) and open your Visual Design File.<br><br>

We will print the music card design on the back side of the printed silver circuit. <br>
Make sure that you flip the photo paper with correct rotation so that the music card visual design and the circuit design matches up. <span style="color:red">Please add a photo Junyi.</span><br><br>

Repeat the steps from above, i.e. choose all the same print settings. <br><br>
<!--  (i.e choose <span style="color:red">glossy paper</span>, high quality print .etc) but do <b style="color:red">not</b> hit the 'grayscale' checkbox since we want to print in color for higher visual quality. <br><br>
 -->
Once you have the visual design printed on the back side it should look like this. 

Front and back:<br>
<img src="images/lab1-assembled.jpg" width="357px" />
<img src="images/lab1-assembled2.jpg" width="357px" /><br><br>

<h2 class="headline">(3) Wiring Up the Button</h2>

<h4>ESP Micro-Controller</h4><br>

We will use the ESP32 micro-controller in this course to control the printed sensors and displays (same as in 6.08). Here is the pin out again for your reference.<br><br>

<img src="images/esp32-pinout.png" width="500px" /><br><br>

If you study the reference sheet closely, you will notice that there are some pins that labelled with "TOUCH". They are optimized to serve as receivers for capacitive sensing therefore return more clean signals, so we will use them for our sensing application.<br> 
However, <b>do not use the one pin labeled as pin0 (TOUCH1) as receiver</b> at any time, as the pin is not configured correctly on this version of ESP32 board and will significantly slow down the signal recording. However, you can still use the pin as a sender. <br><br>

<h4>Setting up the ESP Microcontroller</h4><br>

If you did your homework, you should already be all set.<br>
If for whatever reason you were not able to do it yet, you can find the <a href="esp-setup.html">install instructions here.</a><br><br>

<h4>Connecting your Printed Circuit to a Breadboard and to the ESP</h4><br>

We will use crocodile clamps to connect the touch buttons and slider segments to a breadboard.<br>
One side of the crocodile clamp goes onto the connector pad of each touch button and slider segment.<br>
The other side should clip onto the end of a regular breadboard wire.<br>
The regular breadboard wire can then be used to connect to the breadboard.<br>
From there you can do your normal breadboarding to connect to the ESP.<br>
To get started, use the first crocodile clamp and connect it to the card and a wire for breadboarding.<br><br>

<img src="images/lab1-crocodile-clamp-wire.jpg" width="557px" /><br><br>

<h4>Build Circuit for Touch Sensing</h4><br>

We will implement touch sensing based on the principle of capacitive touch sensing.<br><br>

The circuit for capacitive touch sensing requires a sender pin, which outputs a signal, and a receiver pin, which listens to the signal. The conductive touch buttons and slider segments are connected between the sender and receiver pin, i.e. when a user touches the touch button, the signal will change and thus the receiver pin will receive a different signal, which we can further analyze in our code. The circuit also requires a resistor.<br><br>

<img src="images/lab1-circuit.png" width="300px"><br><br>

<img src="images/capsense.png" width="300px"><br><br>

Let's put this into practice and create our first touch button circuit.<br>
We will use <b>pin 2 as the sender</b> and <b>pin 4 as the receiver</b> (see image).<br> 
You can of course use other pins as well but let's stick with 2 and 4 for this example.<br>
We will use one <b>100k Ohm resistor</b>.<br><br>

<h2 class="headline">(4) Sensing the Touch Signals</h2>

<h4>Install Arduino Capacitive Sensing Library</h4><br>

Next, we will write a program that receives the touch sensor signal and plots them on our computer.<br>

To process the sensor signals, we will use the <b><a href="https://playground.arduino.cc/Main/CapacitiveSensor/">CapacitiveSensor library</a></b>.<br>
To install it it, go to <b>Sketch -> Include Library -> Manage Libraries</b> and search for the <b>CapacitiveSensor</b> library and install it.<br><br>

<img src="images/capacitivesensorlibrary.png" width="650px"><br><br>

If the installed library does not work for you and returns an error message like "'XXX' does not name a type" upon compiling, remove it and we will install it a different way. You can remove the previously installed library: on Mac this is under <b> Macintosh HD/Users/your-username/Documents/Arduino/libraries </b> and on windows this is under <b> My Documents\Arduino\libraries\ </b>).<br><br> 

Once the library is deleted, go to the library's <b><a href="https://github.com/PaulStoffregen/CapacitiveSensor">GitHub repository</a></b> and download it as a .zip file. Re-install the library via the .zip file. The instructions to do so can be found <b><a href="https://www.arduino.cc/en/guide/libraries#toc4">here.</a></b> <br><br>

<h4>Write Code to Read Touch Signal</h4><br>

The basic program below can read one touch sensor and send it to Arduino's serial monitor.<br>
You can download this starter code <a href="images/touch-button.zip">here</a> or alternative you can copy paste from this website.<br>

<code><pre>

/*******************************************************************************
* Capacitive Sensing for Touch and Proximity
*
* Prints the values of a capacitive sensor.
*
*******************************************************************************/
#include &lt;CapacitiveSensor.h&gt;

double analog_touch;

int sender = 2;

int touch_pin_1 = 4;

int samples_touch = 10;

CapacitiveSensor sensor1 = CapacitiveSensor(sender, touch_pin_1);

void setup()
{
   Serial.begin(9600);
}

void loop()
{
  
  // Send value 1
  analog_touch = sensor1.capacitiveSensor(samples_touch);
  Serial.println(analog_touch);


  delay(10);
}
</pre>
</code>
<br>

Open the code in your Arduino IDE and upload it to your microcontroller.<br>
Open the serial monitor, you should see a bunch of numbers fly by.<br>
If you touch your touch sensor, the values should change significantly.<br> 
Remember to not touch the silver side directly but to interact on the side of the visual design, i.e. the side that has no silver. <br><br>

<img src="images/lab1-touching-plotting.png" width="680px"><br><br>

<h4>Extend Circuit to all Three Touch Sensors</h4><br>

Since we have three notes that serve as touch buttons, we need to both extend our circuit as well as our code to read those touch signals as well.<br><br>

Use a breadboard to make 3 touch button circuits, each connecting to one of the notes.<br>
Note that you can use the <b>same sender pin</b> for all three touch buttons.<br>
Only the receiver pin has to vary, i.e. you need one receiver pin for each touch signal you want to read.<br>
Also each touch sensor needs its own 100k Ohm resistor.<br>
Choose any suitable receiver pin number you like.<br><br>

<!-- Connect pin 2 (sender) with three 100k Ohm resistor to the receiver pins 4 (already done), 17, and 18.<br>
Then connect pin 4 (already done), 17, and 18 with a wire and crocodile clamp to the touch sensors.<br><br>
 -->
<h4>Extend Code to all Three Touch Sensors</h4><br>

Next, extend your code to read and print all 3 of your touch sensors.<br>
When you print your touch values, please <b>use Serial.print()</b> not Serial.println().<br>
Each value should be seperated by a tabulator symbol Serial.print(","); and the line should finish with a new line Serial.print("\n").<br><br>

<h4>Plotting Signals on the Serial Plotter</h4><br>

Next, we will use the Serial plotter to visualize the received signals by clicking on <b>Tools->Serial Plotter</b>.<br>
Because of the formatting we used (comma seperated using Serial.print()), we can see all three variables plotted at the same time.<br><br>

Try touching the sensors and see how the signal changes when you touch the sensors.<br>
Below you see how we touch the button 1 first, then button 2 and finally button 3.<br><br>

<img src="images/lab1-plotting-signals.png" width="680px"><br><br>

Also change the values of <b>samples_touch</b> in your code and see how the value range changes.<br>
Below are two examples with higher numbers for samples_touch.<br>

<img src="images/lab1-plotting-signals2.png" width="680px"><br><br>
<img src="images/lab1-plotting-signals3.png" width="680px"><br><br>

<h4>Thresholding Touch Signals: Touched or not Touched?</h4><br>

Next, we want to rewrite our code so to not return the raw signal values but to return if a button was touched or not touched.<br><br>

For each sensor, we want to reformat our output so that:

<code>(sensor ID),(is_touched);</code><br><br>
    
(sensor ID) is either 0, 1 or 2 and represents the ID of the observed touch sensor.<br>
(is_touched) is either 0 or 1 (0 if the sensor is not touched, and 1 if it is touched).<br><br>

A sample output for touching only sensor 0 should look like:<br>
<pre><code>0,1;
1,0;
2,0;
</code></pre>

The sensor ID is easy to plot, but how do we know if the sensor is touched or not?<br>
As you saw in the serial plotter, the values for each sensor can vary pretty wildly as mentioned in lecture.<br><br>

We will do more filtering of signals later, for now you can use a simple if/then statement and make a rough estimate in which range your sensor signal falls for each touch button (look at the serial plotter for some help in determining the range).<br><br>

Rewrite the code such that it iterates over all sensors and outputs every 200ms the correct output (see sample output above again for correct formatting).<br>
We are still writing to the Serial Monitor, so use strings for your numbers.<br><br>

<h4>Print Serial Messages only when Button State Changes</h4><br>

So far we have been printing all touch button values to the Serial monitor no matter if the state of the touch button changed or not.<br>
Next, we want to print new information only if the sensor state changes, i.e. a touch button was not touched before but is now being touched, or the touch button was touched but the user just released the finger.<br><br> 

Change the code such that it tracks in which state each sensors is currently in.<br> 
Check for a state change and send the Serial message only then. <br><br>
Example:<br><br>

If sensor 0 gets touched, this message is printed once:<br>
<pre><code>0,1;</code></pre>

Then when the user lifts the finger again, this message is printed once:<br>
<pre><code>0,0;</code></pre>

<br>

<h4>Serial Communication to Send Touch Signals to Processing</h4><br>

Let's zoom out for a moment.<br>
What we have done so far is that we have written a program for our microcontroller in the Arduino Programming Environment.<br>
We have then uploaded that program onto our ESP microcontroller.<br>
The microcontroller is constantly running our program on its built-in processor going through the loop() function, reading the sensor signals and thresholding them.<br>
It then communicates the sensor signals in the format we defined back to our laptop using Serial communication through the USB cable.<br>
So far, we have only used the Arduino IDE to 'listen' to the Serial communication from the USB cable and to show the values in the Serial Monitor or the Serial Plotter.<br>
However, since any software can listen to the Serial Communication, we can also write programs in other programming languages and IDEs to read and do something with the sensor signals.<br><br>

In the next lab, we are going to write a program in Processing.<br>
Processing is a programming environment that makes it very easy to built on-screen UIs.<br>
For our purposes, we will build a digital version of our music card that will highlight the corresponding areas on the card when you push the button on the physical card and will also play the corresponding song.<br>

<h2 class="headline">Deliverables Lab 1 (due Friday, Sept. 11, 2020, 11.59pm)</h2>

Upload to your student google drive:
<ul>
	<li>the circuit drawing (.pdf file format) you used for conductive inkjet printing</li>
	<li>the Arduino code you wrote for Serial Communication (.ino file format)</li>
</ul>



<!-- <span style="color:red">we still have to change the signal to plot not as a string "1" but as an integer 1, we can do this at the start of the next lab.</span> -->

<!--
<h2 class="headline">Laser Cutting the Mask Layer for your EL Display</h2>

Next, design the mask layer for your EL display.<br>
You could cut it out with scissor, a cutting plotter, or a laser cutter.<br>
For today, we will use a laser cutter.<br><br>

To make a file for laser cutting, you need to stick to a few specifications.<br>
The document you will create your mask layer in has to be RGB mode.<br>
The line color has to be pure red (R=255, G=0, B=0).<br>
The line thickness needs to be 0.0001mm or less.<br><br>

<img src="images/exercise-drawing.png" width="217px" /><br><br>

Once you create the mask layer, send us the file. <br>
We will then help you to log in remotely into our laser cutter computer to cut the file under our guidance.<br>
You will then receive it with your next package.<br><br>

<img src="images/laser-cutter.png" width="317px" />
<img src="images/laser-cutter-cutting.png" width="317px" /><br><br>

-->




<!--Follow these instructions to add the ESP32 library to the ARDUINO IDE: <a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/</a><br><br> -->

<!-- 
<b>Continous Sliders (Different Aesthetic Design Options):</b><br>
<img src="images/slider-designs3.png" width="300px"> <img src="images/slider-designs2.png" width="300px"><br>
From the paper <a href="https://dl.acm.org/doi/10.1145/2971763.2971777">DuoSkin (ISWC 2016)</a><br><br>


<h4>Dials (aka multiple touch buttons circularly arranged)</h4><br>

Touch-dials consist of multiple touch buttons circularly arranged, i.e. several shapes and each shape has its own wire that connects to the micro-controller.<br><br>

<img src="images/dial.png" width="300px"><br>
Example from the paper <a href="https://dl.acm.org/doi/10.1145/2971763.2971777">DuoSkin (ISWC 2016)</a><br><br>

<h4>Electroluminescent Area Display</h4><br>

In your package next week, you will also received a printed display.<br>
This display is called electroluminescent display and we screen printed it from four different materials printed into four layers.<br>
<br>

<b>Making Custom Shaped Displays:</b> The display you will get is a simple area display that can turn on/off but does not have pixels. Note that although we will send you a square display, you can create your own shape either in non-destructive way (allows for reuse) or destructive way. The non-destructive way requires you to mask the display, i.e. cutting a shape from e.g. from cardboard and attaching it to the display to cover the remaining area so that no light comes through. The destructive way includes cutting out the shape (making sure you are not cutting into the wire connection to the microcontroller and also make sure you unplugged the display before cutting since most scissors are conductive on their blades). Since we want you to reuse the display some time, we will use the non-destructive way, i.e. we will laser cut a mask layer in a moment.<br><br>

<img src="images/printscreen2.jpg" width="145px">
<img src="images/printscreen3.jpg" width="345px"><br>
Examples of masked and cut EL displays.<br><br>

Please limit the size of the touch button to something that is roughly the size of a finger tip (an area around 2cm x 2cm) and the wire length to no more than 10cm for now. The display that you will get shipped is 5x5cm in area and you can cut it into any shape you like (not cutting into the wires).<br><br>

 -->

<!-- <h2 class="headline">Making your touch interface designs</h2><br>
    
Open your drawing program and set the document color mode to CMYK.</br>
Draw a design that has at least three different touch buttons, one for a different song each.<br>
It should also include the display that will blink to the beat of the long. Include the display as a square area of XXcm by XXcm so you will leave enough space for it. We will draw the mask layer seperately in a moment.<br>
Make sure you use the correct wire thickness (at least 1mm) and connector pad size (at least 1cm x 1cm), and that you fill each touch button with a fill color (make CMYK = 100).<br>
We recommend all your connector pads route to a common location where you will attach the microcontroller later.<br>
Make sure all the silver you draw has the line/area color 'black (CMYK: 0,0,0,255)'.<br>
The touch button should also be surrounded by a decorative color design to show that you can print color and silver together. <br><br>
 -->
<!-- <img src="images/Cool_Jams.jpg" width="300px"><br> -->


<!-- 
<img src="images/silver-ink.jpg" width="317px" />
<img src="images/silver-inkjet-printing.png" width="317px" /><br><br>
 -->

<!-- <img src="images/touch-button-decorative2.png" width="300px"><br>
Silver touch button in the middle is overprinted with white in a second layer. In addition, the red flame is added as a decorative element (it has no input functionality).<br><br>
 -->

<!-- The shape of the touch buttons and display is completely up to you -- be creative and please don't just make a rectangle. Also keep in mind that the wire does not have to be a straight line but can be any decorative pattern you'd like to use (e.g. a wavy line).  <br><br> -->

<!--
Processing is a program that makes it easy to prototype user interfaces. Once you got your microcontroller in the mail, we will wire everything up and write code to send the touch button input directly to Processing, so that it can visualize if the button is pressed or not. Today, we are going to prepare the UI in Processing so you have everything ready when the rest comes in the mail.<br><br>

<div style="background:#04a47c;padding:10px;">Checkoff 1: The Teaching Team printed your Touch Sensor and it works</div>

</br>

 <h3 class="headline">Install Processing</h3>

You can download Processing for Windows, Mac, Linux here: <a href="https://processing.org/download/">https://processing.org/</a>.<br>
Once you downloaded it, you should see an IDE similar to the one Arduino uses.

<br><br>

<img src="images/processing-ui.png" width="350px"><br><br>

 <h3 class="headline">Code Structure: setup() and draw()</h3>

Similar to Arduino, Processing works with two functions:<br><br>

<b>setup():</b> is only run once at the beginning<br>
<b>draw():</b> is run repeatedly similar to Arduino's loop() function<br><br>

While the simple examples below do not require you to have this structure in place (i.e. you can simple type the code into the empty window, it is good practice to put the code for redrawing the window into draw() and the code that is only required once into setup()).<br><br>

 <h3 class="headline">Getting Started: Drawing a Shape and Mouse Input</h3>

If you haven't done it yet, please do the getting started tutorial to learn how to draw a shape and do mouse input:<br>
<a href="https://processing.org/tutorials/gettingstarted/">https://processing.org/tutorials/gettingstarted/</a><br><br>

<h3 class="headline">Loading in an Image of the Mug</h3>

First, display the image below as the background of your Processing application.<br><br>
Make sure your image file is inside your project folder (Documents -> Processing -> project folder) otherwise it cannot be loaded.<br><br>

To load an image, you can use the <a href="https://processing.org/reference/PImage.html">documentation for PImage</a>.<br><br>

<img src="images/load-image-card.png" width="200px"> <br><br>

 <h3 class="headline">Create Touch Button in Processing</h3>

Processing allows us to quickly create user interfaces on screen.<br><br>

 <h5>Creating Touch Button on Image</h5>

Next, we want to create a touch button and place it on the mug where our final touch button will be in the design.<br>
For simplicity, we will assume that you touch button is rectangular for now.<br>
We will show you later how to load the actual geometry of your button.<br><br>

Make a rectangle with round corners and in silver (gray) color like shown in the image below:<br>
<a href="https://processing.org/reference/rect_.html">Processing Reference for rect()</a><br>
<a href="https://processing.org/reference/fill_.html">Processing Reference for fill()</a><br><br>

<img src="images/processing-fill-color-rect-card.png" width="200px"><br><br>

If you need it later, you can find the full reference here: <br>
<ul><li><a href="https://processing.org/reference/">Complete Processing Reference</a>.</li></ul><br>

 <h5>Changing Color of Button if Button is Pressed</h5>

In the future, we will receive a signal from our Arduino that will either say 'touched' or 'not touched' and based on that we want to visualize in our UI that the button is pressed or not. Here, we are going to simulate this: When the mouse is over the touch button and the mouse is pressed, we want to color the button in green, otherwise the button should remain colored in gray/silver to show that it is inactive. In addition, we want to render a piece of text showing the button was pressed as shown below. <br><br>

To implement this you will need:
<ul>
  <li>if/else statement (works the same as in other programming languages)</li>
  <li>for mouse click, you may want to look at <a href="https://processing.org/reference/mousePressed_.html">Mouse Pressed Processing Reference</a></li>
  <li>for mouse click on the button: unfortunately processing does not have an intersect function, so you need to check if the mouse coordinates are within the X/Y bounds of the touch button</li>
  <li>for the text, you may want to look at <a href="https://processing.org/reference/PFont.html">Processing Reference for Pfont</a> and <a href="https://processing.org/tutorials/text/">text tutorial here</a></li>
</ul>
<br><br>

<img src="images/card-animated.gif" width="250px"><br><br>


<div style="background:#04a47c;padding:10px;">Checkoff 2: Show your completed push/unpush program.</div>


<h5>Importing Vector Graphics</h5>

Next, we will import your actual drawing to the canvas.<br>
For this, we prepared this .svg import class. <br><br>

To load your .svg file, make sure your image file is inside your project folder (Documents -> Processing -> project folder) otherwise it cannot be loaded.<br><br>

You can use the <a href="https://processing.org/reference/PShape.html">Processing PShape reference</a> to see how to load it.</br>
Position it where your former touch button was.</br></br>

If you create your SVG file in Illustrator, make sure you change the following export option: When you save the svg 1) choose "More Options" in the SVG Options dialog, and then 2) select the "Style Attributes" in the drop CSS Properties drop down to make it compatible with Processing. <br><br>

<img src="images/readsvg2.png" width="350px">

<h5>Checking for Mouse Input on a Vector Graphic of Arbitrary Shape</h5>

With a vector graphics, our simple boundary checking doesn't really work anymore, so we need something more sophisticated.<br>
For this, we implemented you the following collision detection class that you can use in your project.<br>

All possible ways are described here <a href="http://jeffreythompson.org/collision-detection/table_of_contents.php">http://jeffreythompson.org/collision-detection/table_of_contents.php</a>.<br>
We provide you with a code file that handles for you the point (mouse cursor) and polygon (shape) detection.<br>
You can read more about it here <a href="http://jeffreythompson.org/collision-detection/poly-point.php">http://jeffreythompson.org/collision-detection/poly-point.php</a><br><br>

<div style="background:#04a47c;padding:10px;">Checkoff 3: Show your vector graphics button.</div>


<h3>Processing Tutorials and Problem Set 1:</h3>

If you still have time left, we recommend you use it to check out some of the <a href="https://processing.org/tutorials/">additional Processing tutorials</a>.<br><br>

Alternatively, you can start with <a href="conductive-inkjet-design.html">Problem Set 1, which we released today.</a>



<!-- 
<b>Materials and Layerstack:</b> An EL display contains (1) phosphor, which can glow when current is applied. To make it glow, the phosphor has to be sandwiched by a bottom and top electrodide. The bottom electrode can be a conductive material, such as (2) our silver ink (alternatively copper can be used for even higher conductivity). The top electrode cannot be made from silver since you would otherwise not see the phosphor anymore! Thus, the top electrode is made from a transparent conductive material called (3) PEDOT:PSS. Finally, since the phosphor and the electrodes are all conductive, we cannot lay them all on top of each other since this would create a short circuit. Therefore, we need to add (4) a dielectric insulating layer between the bottom electrode and the phosphor (conceptually, the dielectric could also be between the phosphor and the top electrode, but again then you wouldn't see anything anymore since the dieletric is not transparent). <br><br>

You can buy the materials here: <br>
<ul>
	<li>copper ink (add link)</li>
	<li>PEDOT:PSS (add link)</li>
	<li>Phosphor (add link)</li>
	<li>Dieletric (add link)</li>
</ul>

<img src="images/el-materials.png" width="400px"><br>
<img src="images/el-layerstack.png" width="500px"><br><br>

<b>Size of each layer:</b> Note that the dieletric layer is a bit larger than the other layers. Since the dieletric layer prevents everything from short circuiting, it should be a bit larger to make sure all other layers are really seperated from each other and not touching. <br><br>

<img src="images/el-area-sizes.png" width="500px"><br><br>

<b>Fabrication:</b> While the silver ink and PEDOT:PSS can be inkjet printed, the phosphor and dieletric have unfortunately too large particules in their inks, which clogg printer nozzles. We there screen printed the display you got. Below, you can see images of how we did it.<br><br>

<img src="images/screen-printing.jpg" width="500px"><br><br>
 -->


<br>

        <br />
        <br />
        <br />
      </section>

      <aside class="col-md-4 pull-left">
         <br /> <br /> <br /> <br />
<!-- 				 <h4>Pset Steps</h4><br>
				 <ul>
		 			<li><a href="#pset1">pset1 (due Sept. 21, 11.59pm): laser cut and bend the acrylic base</a><br /></li>
		 			<li><a href="#pset2">pset2 (due Oct. 5, 1pm): insert LEDs, add USB connecting and solder everything</a><br /></li>
		 			<li><a href="#pset3">pset3 (due Oct. 19, 1pm): write touch recognition so that you can determine (x,y) location of each finger</a><br /></li>
		 			<li><a href="#pset4">pset4 (due Oct. 26, 1pm): add an application of your choice</a><br /></li>
				</ul>
				<br /> <br /> <br /> <br />
        <img src="../2018-fall-6810/images/multi-touch-pad/iap1.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad/iap2.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad//iap3.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad/iap4.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad/iap5.jpg" width="220px">
 -->



        <!-- Publication -->

        <br><br><br><br><br>

        <!-- Publication -->

<!-- <h4>Side Bar</h4><br>

    <ul>
      <li>Prof. Stefanie Mueller (Instructor)</li>
      <li>Lotta-Gili Blumberg (TA)</li>
      <li>Xin Wen (UTA)</li>
      <li>Loren Maggiore (LA)</li>
      <li>Mark Chounlakone (LA)</li>
    </ul>
 -->
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>

      </aside>

    </div>
  </div>
  </div>
</section>

<div class="container">
	<div class="row">
		<div class="col-md-12 footer" style="text-align: center;">
			<span class="copyright">
			Since 2017 &copy; MIT CSAIL (HCI Engineering group) [redesign by
			<a href="http://punpongsanon.info/" target="_blank" style="text-decoration:none; border-bottom:0px">
			moji
			</a>].
			All Rights Reserved.

			<a href="http://mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/mit.svg" alt="MIT" class="footer-logo" />
			</a>
			<a href="http://csail.mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/csail.svg" alt="CSAIL" class="footer-logo"/>
			</a>
			<a href="http://hci.csail.mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/hci.svg" alt="HCI" class="footer-logo"/>
			</a>
			</span>
		</div>
	</div>
</div>

<!-- Bootstrap -->
<script type="text/javascript" src="../../js/bootstrap.min.js"></script>
<!-- header -->
<script type="text/javascript" src="../../js/headerstrap-for-subpage.js"></script>

</body>
</html>
