<!DOCTYPE html>
<html>
<head>
	<title>6.810 Pset3 Touch Signals</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

	<!-- CSAIL ICON -->
	<link rel="CSAIL" href="../../images/icon/csail.ico" type="image/x-icon" />

	<!-- Bootstrap -->
	<link href="../../css/bootstrap.css" rel="stylesheet">
	<link href="../../css/custom-style.css" rel="stylesheet">

	<!-- jQuery -->
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

	<!-- Prism for adding the code snippets-->
	<link href="../../css/prism.css" rel="stylesheet" />

	<!-- Google Fonts -->
	<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Abel" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Barlow" rel="stylesheet">

	<!-- Google Analytic -->
	<script type="text/javascript" src="../../js/analytics.js"></script>

	<style>
	.etech-sch-col1 {width:60px; border: 1px solid black;padding:10px;}
	.etech-sch-col2 {width:120px; border: 1px solid black;padding:10px;}
	.etech-sch-col3 {width:450px; border: 1px solid black;padding:10px;}
	.etech-sch-col4 {width:70px; border: 1px solid black;padding:10px;}
  .etech-sch-col5 {width:70px; border: 1px solid black;padding:10px;}
  /*.etech-sch-col6 {width:170px; border: 1px solid black;padding:10px;}*/
  ul {
    padding:0px;padding-left:10px;margin:0px;
  }
	</style>
</head>

<body>
<header class="main_header">
	<!-- to be filled by javascript, see header.html -->
</header>

<script src="../../js/prism.js"></script> 

<section class="main_container">
	<div class="container">
    <div class="row nothing">

      <section class="col-md-8 pull-right main-content">
</br></br></br></br>
        <h4 class="medium.headline"><a href="6810-engineering-interactive-technologies.html">6.810 Engineering Interactive Technologies (fall 2021)</a><br></h>
        <h2 class="headline">Pset3: Sensing Multi-Touch Input</h2>

In this problem set, you will write Arduino code to sense the touch signals from your multi-touch pad. At the end of this problem set, you will be able to recognize when a user is touching.<br><br>

<b>Steps:</b>
<ol>
	<li><a href="#PWM">Generate PWM Signal on ESP Sender Pin</a></li>
	<li><a href="#Multiplexer">Use Multiplexer to Send PWM Signal to Specific Electrode Columns</a></li>
	<li><a href="#SPI">Read Signals from Electrode Rows via SPI Communication</a></li>
	<li><a href="#Signals">Inject and Read Signals in the Correct Order</a></li>
	<li><a href="#debug">Debug Circuit</a></li>
</ol>
<br>

 <div style="color:black; border: black 1px solid; padding: 20px;margin-bottom:20px;">
<b>Help us Improve Class Materials for PSet3:</b><br>
Please let us know if anything was confusing in the write up or if you had trouble with the test program. <br> <a href="https://docs.google.com/document/d/1J2MiBfqJrjhseLlMEqzxT8vBO5pm3Irjl7q9v3_NdrM/edit?usp=sharing">You can add your comments here.</a></div>

 <div style="color:black; border: black 1px solid; padding: 20px;margin-bottom:20px;">
<b>Ask a TA to give you a wired up multi-touch pad if something went wrong in pset2</b><br>
In case you did not finish pset2, you can ask a TA to provide you with a wired up multi-touch pad, i.e. with the completed circuit. If you finished pset2, but it turns out that your circuit is incorrect you can either ask a TA to fix it with you or they can give you a new clean circuit they built from scratch.</div>

<h3 id="PWM">(1) Generate PWM Signal on ESP Sender Pin</h3>

Let's start by writing the code that generates the PWM signal at the sender pin. <br><br>

<b>Pulse Width Modulation (PWM):</b> Remember from the EL display lab that PWM is a technique that can be used to create voltages in-between 0V and 3.3V by switching the signal at the PWM pin on and off. The longer the signal is off, the lower the voltage. In the EL-display lab we had used PWM to dim our display since the amount of voltage determines how bright the display is. Here in our multi-touch pset, we use PWM to generate a time-varying voltage at a constant frequency, which will allow us to determine changes in capacitance when the user is touching (this is more advanced electronics and we spare you the details). <br><br>


<!-- . As one of the physical principles of capacitive sensing, when the electric potentials on the conductors are time-varying, a current known as the displacement current flows through the capacitor, and the capacitance can be measured by observing that (displacement current). The voltage signal generated by PWM channel can act as the electric potential load between transmit and receive electrodes.  -->

<img src="images/pset3/multitouch-schematic-sending.png" width="450px"> <img src="images/pset3/pwm-explanation.png" width="250px"> <br><br>

<b>Download Skeleton Code:</b> Start by downloading <a href="software/pset-skeleton_Arduino.zip"><span style="color:blue">the skeleton code for pset3 from here</span></a>. You will fill out the 'setupPWM()'' function to create the PWM signal using the steps below.<br><br>

<img src="images/pset3/setuppwm-function.png" width="350px"> <br><br>

<b>Configuring the PWM Signal:</b> First, you need to specify which type of PWM signal you want to generate. For this, you can use the 'ledcSetup()' function, which generates the PWM signal on the LED control (LEDC) peripheral. The function name reflects that it is primarily designed to control the intensity of LEDs, but it can also be used to generate PWM signals for other purposes. <br>

<pre>
	<code class="language-c">
		ledcSetup(int channel_number, int frequency, int duty_resolution)
	</code>
</pre>

<i>Channel Number:</i> The LEDC peripheral has 16 channels which can generate independent waveforms (note that these are NOT pin numbers on the ESP, but internal channels inside the ESP). The channel numbers range from 0-15. For our purposes, you can pick any channel number you like as the parameter.<br><br>

<i>Duty Resolution:</i> Let's recap briefly from the EL display lab. The <code>duty cycle</code> is defined as the percentage of the period for which the signal is "high" (see image above on the right). For example, a signal that has a 50% duty cycle is high for one half of the period and low for the other half, whereas a 25% duty cycle is high for only the first quarter and then low for the remaining three quarters. In the EL display lab, this has resulted in different brightnesses, i.e. 50% duty cycle is brighter than 25% duty cycle. For the display lab, we wanted to have 8 different brightnesses for dimming and had thus chosen a <code>duty resolution</code> of 3 bits, which can generate up to 8 different PWM duty cycles (in addition to a 0% PWM duty cycle which is not counted in the 3 bits since it's the default). Let's apply this to our multi-touch pad. For the multi-touch pad, we need a duty cycle of 25%. We spare you the details of why exactly we need this duty cycle. What is the smallest duty resolution that can create a 25% duty cycle? <a href="https://forms.gle/cjM1baraYAj9GUof6" style="color:blue">Submit your answer here (question 1)</a> and then use it as the parameter in the function.<br><br>

<i>Frequency:</i> For multi-touch sensing, we need a frequency of 4MHz. We will spare you the details why we need exactly this frequency. Unfortunately, the available PWM frequencies are directly affected by the duty resolution. The higher the duty resolution (i.e. the more bit), the lower the available PWM frequencies. So how do we know if we can support 4MHz with our chosen duty resolution? Luckily, some people created this formula for you to check:

<pre>max available frequency = microcontroller clock cyle / 2^bits from the duty resolution <br>// microcontroller clock cycle (80MHz for ESP32) divided by 2 to the power of bits <br>// from the duty resolution</pre>

If we need at least 4MHz for the frequency, what are the possible duty resolutions we could use that would still enable a frequency of 4MHz or more?  <a href="https://forms.gle/cjM1baraYAj9GUof6" style="color:blue">Submit your answer (question 2) here in the Google Form</a>.</b> We hope you come to the conclusion that our chosen duty resolution is valid for 4MHz and you can thus use the value as the parameter in the function. Note that the function takes the frequency in Hz, so you need to do the conversion and then enter that number into the parameter.<br><br>

<b>Specify the Output Pin of the PWM Signal:</b> Now that you configured the PWM signal that will be generated by the LEDC peripheral, you need to specify on which ESP pin number the signal should appear. Use the GPIO pin that goes from the ESP to the multiplexer's SIG pin. The PWM channel number is the same as above. <br>

<pre>
	<code class="language-c">
		ledcAttachPin(GPIO_PIN, channel_number);
	</code>
</pre><br>

<b>Generating the PWM Signal on the Output Pin:</b> Finally, you need to tell the ESP which duty cycle you want to use for your PWM signal and generate the actual signal using the ledcWrite() function:<br> 

<pre>
	<code class="language-c">
		ledcWrite(channel_number, duty_cycle);
	</code>
</pre>

<i>Duty Cycle:</i> In the duty cycle parameter, you tell the ledcWrite() function, which of the duty cycles from your duty resolution should be used. Continuing the example from above, let's assume you chose 4 bits, which gives you 16 values ranging from 6.25%, 12.5%, 18.75%, 25%, 31.25% .... 100%, then your duty cycle parameter is the index of the duty cycle you want to use. For instance, using 2 would give you 18.75% for the duty cycle. Based on the duty resolution you chose for question number 1, choose the correct duty cycle parameter. <a href="https://forms.gle/cjM1baraYAj9GUof6" style="color:blue">Submit your answer (question 3) in the Google Form here and then use it as the parameter in the function.</a><br><br>

Once you submitted all your answers with the google form, feel free to reach out on slack to have your answers confirmed. Even if your PWM is wrong, you can still work on section #2 and #3 and everything should be fine. Only section #4 may give you a weird signal if something is wrong with your PWM.<br><br>


<h3 id="Multiplexer">(2) Use Multiplexer to Send PWM Signal to Specific Electrode Columns</h3>

Now that you are generating the PWM signal at the ESP GPIO sender pin that is connected to the multiplexer SIG pin, you are ready to write a function that will tell the multiplexer to which pin (i.e. electrode column) it should forward the signal to. Note that even if you did not get the PWM signal in section #1 working, you can still work on this section here (instead of the PWM signal just use digitalWrite(HIGH) for the multiplexer's SIG pin).<br><br>

<img src="images/pset2/multiplexer.png" width="350px"><br><br>  

<b>How to redirect the signal to a desired channel?:</b> The multiplexer receives the PWM signal on the <code>input pin (SIG).</code> It then needs to determine to which of the <code>output pins (C0-C15)</code> the signal should be forwarded to. To do this, it uses the <code>address pins S0 - S3</code> to create the address that determines which output pin (electrode column) the signal should be send to. Why four pins? The multiplexer expects a binary signal. For instance, sending 0,0,0,0 to S0-S3 results in the output pin C0. In contrast, sending 0,1,1,0 sends the signal to C6. Notice that you don't have to store everything in binary as long as you are comfortable with bit operations in C, for example <code class="language-c">int number & 1</code> (or <code class="language-c">int number & 0001</code>) will return the least significant bit of the <code class="language-c">number</code>, and <code class="language-c">int number & 2</code> (or <code class="language-c">int number & 0010</code>) will return the second to least significant bit of the <code class="language-c">number</code>. All solutions are welcome here as long as it works. Let's implement this in the next section.<br><br>


<b>Setup Address Pins (S0-S3) as Digital Pins:</b> First, check which GPIO pin numbers you used for the multiplexer's S0 - S3 pins. Create the digital pins in your Arduino code and set the correct PinMode. <br><br>

<b>Compute the Bit Values for the Address Pins:</b> Fill out the <code>selectChannelOut(int channel)</code> function in the skeleton code. The function takes as input an 'int' for the channel number (0-8, since we have 9 sender lines in our 8x9 multi-touch pad) and then assigns the correct bit values to the 4 select pins (S0 - S3). Use 'digitalWrite' to write the correct value to each of the S0-S3 pins after you determined if they should be 0 or 1.<br><br>

<img src="images/pset3/selectchannelout-function.png" width="580px"> <br><br>

<b>Testing the Multiplexier Channel Select Function:</b> You can test if your channel selection function works properly in the following way: First, choose one of the C0-8 channels as the output pin for testing and set it in your <code>selectChannelOut(int channel)</code> function, upload the code to the ESP. Next, connect the <code>SIG pin</code> on Multiplexer to the ESP32's <code>3.3V pin</code>, which will create a 'HIGH' signal that your code will forward to your chosen C0-8 pin if all works correctly. Use a multimeter in 'V' mode and measure with one probe on your chosen C0-8 pin and the other probe on GND. You should see 3.3V in the display if everything is ok. If you see 0, no voltage is applied. If it's not working, check both your code and your wiring.<br><br>

<img src="images/pset3/multimeter-v.png" width="250px"> <br><br>

<h3 id="SPI">(3) Read Signals from Electrode Rows via SPI Communication</h3>

Now that you can foward the PWM signal to specific electrode columns, you are ready to write the code for reading the signals from the electrode rows. Note that even if you did not finish section #2, you can still work on section #3 here.<br><br>

Remember from pset2 that we had wired up an additional ADC converter (MCP3008 chip) to get cleaner signals from our multi-touch pad, i.e. the MCP3008 chip converts our analog touch signals better than the ESP GPIO pins would be able to do. We had also discussed that the MCP3008 chip <a href="pset2-multitouch-assembly.html#RECEIVING">communicates with the ESP via the Serial Peripheral Interface (SPI)</a>. To write code that reads the signals via SPI, you will have to do the following steps. <br><br> 

<b>Install MCP3008 Library</b>: Download and install the MCP3008 library by opening the Arduino IDE and going to <code>Sketch -> Include Library -> Manage Libraries</code> and search for the <code>MCP3008</code> library. Restart your Arduino IDE after you installed the library.<br><br>

<img src="images/pset3/mcp3008-library.png" width="700px"> <br><br>

<b>Look at MCP3008 Example Code</b>: Go to <code>File -> Examples</code> and look at the bottom where it says <code>Examples from Custom Libraries</code> to find example code that shows how to use the MCP3008 library. We recommend you look at the <code>simpletest</code> example.<br><br>

<img src="images/pset3/mpc-library-examples.png" width="400px"> <br><br>

<b>Include Library</b>: As you can see in the simpletest example, you need to first include the library on top in the skeleton code.<br><br> 

<b>Instantiate Library</b>: After this, you need to declare an object of the library.<br><br>

<b>Open Communication Channel</b>: Next, you need to open the SPI communication channel with <code>begin()</code> in the setup function. However, we do not want to use the empty contructor begin() but instead also provide the pin numbers. You can see an example of this further down in the 'simpletest' example in the code that is commented out. Fill the pin numbers in according to your wiring.<br>

<!-- <img src="images/pset3/mpc-library-function.png" width="400px"> <br><br> -->
<pre>
	<code class="language-c">
		// Software SPI (specify all, use any available digital)
		// (sck, mosi, miso, cs);
		adc.begin(13, 11, 12, 10); // for ESP32, use (14, 13, 12, 25)
	</code>
</pre><br>


<b>Start reading signals</b>: Once the channel is open, you can read the signal from one of the input channels CH0-CH7 using the <code>readADC(channelnumber)</code> function (see the 'simpletest' example code). If you serial print the result, you should see your analog signal coming through.<br><br>

<b>Testing your Code:</b> You can check if the SPI communication between the ESP and the MCP chip works properly by doing the following: Instead of connecting your multi-touch pad to the MCP chip, connect a GPIO pin from the ESP to one of the MCP chip CH input channels and set the GPIO pin to 'HIGH'. Next, read the signal with the readADC(channelnumber) function and plot the result on the Serial Plotter. You should see a signal there around 1000. If you see '0' your SPI communication is not working and nothing is coming through. You either <a href="pset2-multitouch-assembly.html#RECEIVING">wired up the MCP chip incorrectly in pset2</a> or you are reading from the wrong channel.<br><br>

<h3 id="Signals">(4) Inject and Read Signals in the Correct Order</h3>

Now that you have code for injecting and reading signals, you are ready to write the meta-level code that tells your program when to inject into which electrode column and when to read which of the electrode rows.<br><br>

<b>Putting your Code in loop():</b> Since we will continuously read data from our multi-touch pad, your code should be in the <code>loop()</code> function. <br><br>

<b>Inject Column #1, Read all Rows, Inject Column #2, Read all Rows...:</b> Your code needs to first send a signal through column #1, then read each row of the multi-touch pad one after another (rows #1-#8), and then inject the signal into column #2, read again row #1-#8 and so on.<br><br>

<b>Averaging Read Signals: </b> When reading the signal from a specific row, sample multiple times (e.g., execute read() 20 times and average the readings together) to get a more accurate and smooth signal. You should do the multiple sampling and averaging before you move on to the next row.<br><br>

<b>Print Data to Serial Monitor:</b> Serial print the data in the format: columm0, row0val, row1val, row2val... Please follow the specific format since we will use it later to read the data into Processing. A sample serial output would look like this: <br>
<pre>
0,50,83,58,79,108,75,82,54   //columm0, row0val, row1val, row2val
1,55,92,120,84,63,61,88,53   //columm1, row0val, row1val, row2val
2,61,64,73,66,92,78,67,57
3,65,117,116,84,48,81,91,71
4,65,128,116,54,76,81,88,59
5,61,86,66,54,114,78,64,64
6,59,86,120,83,85,75,93,63
7,56,86,116,70,72,83,80,64
8,23,82,74,68,98,64,62,52
...
</pre> <br>

<b>Checking Result in Serial Plotter:</b> If you open up the Serial Plotter, it should look like the image on the left when the multi-touch pad is not touched, i.e. all values are roughly the same height. The middle shows a start of touching and the right the end of touching. If you do not see these, please move on to the next section that will help you debug common problems.<br><br>

<img src="images/pset3/multi-touch-pad-not-touch.png" width="250px"><img src="images/pset3/multi-touch-pad-touch-1.png" width="250px"><img src="images/pset3/multi-touch-pad-touch-2.png" width="250px"><br><br>


<h3 id="debug">(5) Debug Circuit</h3>

If you do not see the above signals on your Serial Plotter, you can check the following parts of your circuit before coming to OHs for help. <br><br>

<b>Testing the Generated PWM signal:</b> If you want to test if you are generating the correct PWM signal, we will have an oscilloscope ready in lab and at the OH. If you know how to use an oscilloscope, you can also use it yourself outside the OH. <br><br>

<img src="images/pset3/oscilloscope.jpg" width="450px"><br><br>  

<b>Tuning the Multiplexer Delay Function:</b> In the skeleton code the function <code>selectChannelOut(int channel)</code> has a delay() function. You may need to adjust the delay slightly depending on the amount of capacitive coupling your specific circuit layout has. 

Capacitive coupling slows down the signal writing process to pins and can cause the multiplexer to fall behind with assigning the correct output channels C0-C8 based on the pin values from the address pins S0-S3, thus writing into the wrong output channel, which leads to weird behavior. Adding a larger delay allows the multiplexer to receive stable select pin values for S0-S3 and to assign the correct output channel from C0-C8. Usually a delay of 2 - 5 milliseconds is sufficient. <br>

<pre>
	<code class="language-c">
		//----- TODO: Set Select Pin Values -----
		void selectChannelOut(int channel) {
		    
		    // leave this delay at the end of the function,
		    // this is for mux to stabilize after each select pin values assignment
		    // you can adjust the delay value 
		    delay(2);  
		}
	</code>
</pre>
<br>

<b>Check Connections between Multitouch Pad and FPC Connectors:</b> Another aspect to check is whether the inkjet printed wires of your multitouch pad are still connected to your FPC connectors. If the columns are not connected anymore, the injected PWM signal will never reach your multi-touch pad. If the columns are connected to the FPC, but not the rows, a signal will be injected but the signal cannot be read. You can test with a multimeter if the FPCs are still making a connection to the inkjet printed wires, please go to <a href="pset2-multitouch-assembly.html#CONNECTFPC">pset2 section #6</a> if you need a reminder of how to test it. <br><br>

If you still don't see the expected results from Arduino Serial Plotter, please come to an OH and one of our TAs will take a look with you together! <br><br>


<h3>Deliverables</h3>

For grading, please upload the following to your google drive student folder:<br>

<ul>
	<li>the .ino file of your Arduino program</li>
	<li>a short video showing the circuit working, i.e. show that touching the multi-touch pad produces a different signal than not touching the multi-touch pad. Please record at least 2-3 subsequent touches in the video to show it works reliably. Make sure the Serial monitor and your multitouch pad are both visible at the same time.</li>
</ul>


<h3>Grading</h3>

We will give 20 pts in total:
<ul>
	<li>5pts: Does the code generate the PWM signal correctly? Are the answers in the google form correct?</li>
	<li>5pts: Does the code correctly select the channel on the multiplexer to address the correct electrode column?</li>
	<li>5pts: Does the ESP communicate with the MCP chip correctly via SPI to read the signals from the electrode rows?</li>
	<li>5pts: Are the signals injected and read in the correct order? Does the video show touch recognition working reliably?</li>
</ul>


        <br />
        <br />
      </section>

     <aside class="col-md-4 pull-left">
         <br /> <br /> <br /> <br /><br>

                 <h4 class="medium.headline" style="padding-bottom:10px;"><a href="pset-multi-touch-pad.html"><b>Pset Series: Multi-Touch Pad</b></a><br></h4>

<ul>
          <li><a href="pset1-circuit-design.html">Pset1: Generating the Fabrication Files</a></li>
          <li><a href="pset2-multitouch-assembly.html">Pset2: Assembling the Circuit</a></li>
          <li><a href="pset3-signal-processing.html">Pset3: Sensing Multi-Touch Input</a></li>
          <li>Pset4: Visualizing Multi-Touch Input</li>
          <li>Pset5: Gesture Detection<br></li>
</ul><br>


<img src="images/pset-multi-touch-pad/pset-processing1.png" width="350px">
<br><br>

In this pset series, you will create an inkjet printed multi-touch pad. You will first write a Processing program that automatically generates the fabrication files for the multi-touch pad. Next, you will print your multi-touch pad, assemble it, and then build the circuit for sensing touch input. You will then write the microcontroller code for reading the touch signals from each electrode. Next, you will extend your code to draw the touch signals into an image and then extract the touch points via computer vision. Finally, you will write a gesture recognizer that can differentiate between different user inputs.<br><br>

</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>

      </aside>

    </div>
  </div>
  </div>
</section>

<div class="container">
	<div class="row">
		<div class="col-md-12 footer" style="text-align: center;">
			<span class="copyright">
			Since 2017 &copy; MIT CSAIL (HCI Engineering group) [redesign by
			<a href="http://punpongsanon.info/" target="_blank" style="text-decoration:none; border-bottom:0px">
			moji
			</a>].
			All Rights Reserved.

			<a href="http://mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/mit.svg" alt="MIT" class="footer-logo" />
			</a>
			<a href="http://csail.mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/csail.svg" alt="CSAIL" class="footer-logo"/>
			</a>
			<a href="http://hci.csail.mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/hci.svg" alt="HCI" class="footer-logo"/>
			</a>
			</span>
		</div>
	</div>
</div>

<!-- Bootstrap -->
<script type="text/javascript" src="../../js/bootstrap.min.js"></script>
<!-- header -->
<script type="text/javascript" src="../../js/headerstrap-for-subpage.js"></script>

</body>
</html>
