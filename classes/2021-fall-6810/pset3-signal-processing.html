<!DOCTYPE html>
<html>
<head>
	<title>HCI Engineering Group</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

	<!-- CSAIL ICON -->
	<link rel="CSAIL" href="../../images/icon/csail.ico" type="image/x-icon" />

	<!-- Bootstrap -->
	<link href="../../css/bootstrap.css" rel="stylesheet">
	<link href="../../css/custom-style.css" rel="stylesheet">

	<!-- jQuery -->
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

	<!-- Prism for adding the code snippets-->
	<link href="../../css/prism.css" rel="stylesheet" />

	<!-- Google Fonts -->
	<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Abel" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Barlow" rel="stylesheet">

	<!-- Google Analytic -->
	<script type="text/javascript" src="../../js/analytics.js"></script>

	<style>
	.etech-sch-col1 {width:60px; border: 1px solid black;padding:10px;}
	.etech-sch-col2 {width:120px; border: 1px solid black;padding:10px;}
	.etech-sch-col3 {width:450px; border: 1px solid black;padding:10px;}
	.etech-sch-col4 {width:70px; border: 1px solid black;padding:10px;}
  .etech-sch-col5 {width:70px; border: 1px solid black;padding:10px;}
  /*.etech-sch-col6 {width:170px; border: 1px solid black;padding:10px;}*/
  ul {
    padding:0px;padding-left:10px;margin:0px;
  }
	</style>
</head>

<body>
<header class="main_header">
	<!-- to be filled by javascript, see header.html -->
</header>

<script src="../../js/prism.js"></script> 

<section class="main_container">
	<div class="container">
    <div class="row nothing">

      <section class="col-md-8 pull-right main-content">
</br></br></br></br>
        <h4 class="medium.headline"><a href="6810-engineering-interactive-technologies.html">6.810 Engineering Interactive Technologies (fall 2021)</a><br></h>
        <h2 class="headline">Pset3: Sensing Multi-Touch Input</h2>

In this problem set, you will write code to sense the touch signals from your multi-touch pad. At the end of this problem set, you will be able to see when a user is touching.<br><br>

<b>Steps:</b>
<ol>
	<li><a href="#PWM">Generate the PWM signal for the sender pin.</a></li>
	<li><a href="#Multiplexer">Configure the Multiplexer to send the PWM signal to the right electrode column.</a></li>
	<li><a href="#SPI">Receive Signals from Electrode Rows via SPI Communication.</a></li>
	<li><a href="#Signals">Injecting Signals into Columns and Reading Signals from Rows in the correct order.</a></li>
</ol>
<br>

 <div style="color:black; border: black 1px solid; padding: 20px;margin-bottom:20px;">
<b>Ask a TA to give you a wired up multi-touch pad if something went wrong in pset2</b><br>
In case you did not finish pset2, you can ask a TA to provide you with a wired up multi-touch pad, i.e. with the completed circuit. If you finished pset2, but it turns out that your circuit is incorrect you can either ask a TA to fix it with you or they can give you a new clean circuit they build from scratch.</div>

<h3 id="PWM">(1) Generate the PWM signal for the sender pin </h3>

Let's start by writing the code that generates the PWM signal at the sender pin. <br><br>

<b>Pulse Width Modulation:</b> Remember from the EL display lab that PWM is a technique that can be used to create voltages in-between 0V and 3.3V by switching the signal at the PWM pin on and off. The longer the signal is off, the lower the voltage. In the display lab we had used PWM to dim our display since the amount of voltage determines how bright the display is. Here in our multi-touch pset, we use PWM to generate a time-varying voltage at a constant frequency. As one of the physical principles of capacitive sensing, when the electric potentials on the conductors are time-varying, a current known as the displacement current flows through the capacitor, and the capacitance can be measured by observing that (displacement current). The voltage signal generated by PWM channel can act as the electric potential load between transmit and receive electrodes. <br><br>
<!-- <span style="color:red">The PWM signals are generated by a special chip on the ESP called the LED control peripheral, which can generate up to 16 different PWM signals simultaenously. For our purposes, we only need to generate one PWM signal that will be injected into the electrode rows.</span><br><br> -->

<img src="images/pset3/multitouch-schematic-sending.png" width="450px"> <img src="images/pset3/pwm-explanation.png" width="250px"> <br><br>

<b>Download Skeleton Code:</b> Start by downloading <a href="software/pset-skeleton_Arduino.zip"><span style="color:red">the skeleton code for the PSet3 from here</span></a>. You will fill out the 'setupPWM()'' function to create the PWM signal using the steps below.<br><br>

<!-- <img src="images/pset3/setup-pwm.png" width="450px"> <br><br> -->

<b>Configuring the PWM Signal:</b> First, you need to specify which type of PWM signal you want to generate. For this, you can use the 'ledcSetup()' function, which generates the PWM signal on the LED control (LEDC) peripheral. The function name reflects that it is primarily designed to control the intensity of LEDs, but it can also be used to generate PWM signals for other purposes. <br>

<pre>
	<code class="language-c">
		ledcSetup(int channel_number, int frequency, int duty_resolution)
	</code>
</pre><br>

<i>Channel Number:</i> The LEDC peripheral has 16 channels which can generate independent waveforms (note that these are NOT pin numbers on the ESP, but internal channels inside the ESP). The channel numbers range from 0-15. For our purposes, you can pick any channel number you like as the parameter.<br><br>

<i>Duty Resolution:</i> Let's recap briefly from the EL display lab. The duty <b>cycle</b> is defined as the percentage of the period for which the signal is "high". For example, a signal that has a 50% duty cycle is high for one half of the period and low for the other half, whereas a 25% duty cycle is high for only the first quarter and then low for the remaining three quarters (see image above). In the EL display lab, this has resulted in different brightnesses, i.e. 50% duty cycle is brighter than 25% duty cycle. For the display lab, we wanted to have 8 different brightnesses for dimming and had thus chosen a duty <b>resolution</b> of 3 bits, which can generate up to 8 different PWM duty cycles. Let's apply this to our multi-touch pad. For the multi-touch pad, we need a duty cycle of 25%. We spare you the details of why exactly we need this duty cycle. What is the smallest duty resolution that can create a 25% duty cycle? <a href="https://forms.gle/yizyDh85aV4eYp356">Submit your answer here (question 1)</a> and then use it as the parameter in the function.<br><br>

<i>Frequency:</i> For multi-touch sensing, we need a frequency of 4MHz. We will spare you the details why we need exactly this frequency. Unfortunately, the available PWM frequencies are directly affected by the duty resolution. The higher the duty resolution (i.e. the more bit), the lower the available PWM frequencies. So how do we know if we can support 4MHz with our chosen duty resolution? Luckily, some people created this formula for you to check:

<pre>max available frequency = microcontroller clock cyle / 2^bits from the duty resolution <br>// microcontroller clock cycle (80MHz for ESP32) divided by 2 to the power of bits <br>// from the duty resolution</pre>

If we need at least 4MHz for the frequency, what are the possible duty resolutions we could use that would still enable a frequency of 4MHz or more?  <a href="https://forms.gle/yizyDh85aV4eYp356">Submit your answer (question 2) here in the Google Form</a>.</b> We hope you come to the conclusion that our chosen duty resolution is valid for 4MHz and you can thus use the value as the parameter in the function. Note that the function takes the frequency in Hz, so you need to do the conversion and then enter that number into the parameter.<br><br>

<b>Specify the Output Pin of the PWM Signal:</b> Now that you configured the PWM signal that will be generated by the LEDC peripheral, you need to specify on which ESP pin number the signal should appear. Use the ESP pin that goes from the ESP to the multiplexer's SIG pin. The PWM channel number is the same as above. <br>

<pre>
	<code class="language-c">
		ledcAttachPin(GPIO_PIN, channel_number);
	</code>
</pre><br>

<b>Generating the PWM Signal on the Output Pin:</b> Finally, you need to tell the ESP which duty cycle you want to use for your PWM signal and generate the actual signal using the ledcWrite() function:<br> 

<pre>
	<code class="language-c">
		ledcWrite(channel_number, duty_cycle);
	</code>
</pre><br>

<i>Duty Cycle:</i> In the duty cycle parameter, you tell the ledcWrite() function, which of the duty cycles from your duty resolution should be used. Continuing the example from above, let's assume you chose 4 bits, which gives you 16 values ranging from 6.25%, 12.5%, 18.75%, 25%, 31.25% .... 100%, then your duty cycle parameter is the index of the duty cycle you want to use. For instance, using 2 would give you 18.75% for the duty cycle. Based on the duty resolution you chose for question number 1, choose the correct duty cycle parameter. <a href="https://forms.gle/yizyDh85aV4eYp356">Submit your answer (question 3) in the Google Form here and then use it as the parameter in the function.</a><br><br>

Once you submitted all your answers with the google form, feel free to reach out on slack to have your answers confirmed before you move on since they may impact how well your code will work in the rest of the pset3. However, you don't have to check your PWM right now, you will still be able to work on (2) and (3) even if it’s not correct. You can check the (1) correctness at the end. <br><br>


<h3 id="Multiplexer">(2) Configure the Multiplexer to send the PWM signal to the right electrode column</h3>

Now that you are generating the PWM signal at the sender pin on the ESP that is connected to the multiplexer, we will write up the function that determines to which pin (i.e. electrode column) the multiplexer will send the signal as output. Note that even if you didn’t get PWM signal in (1) working, you can still work on this section here in (2), just use digitalWrite(HIGH) for the multiplexer's SIG pin for now.<br><br>

<img src="images/pset3/multiplexer.png" width="350px"><br><br>  

<b>How to redirect the signal to a desired channel?:</b> The multiplexer receives the PWM signal on the input pin (SIG). It then needs to determine to which of the output pins (C0-C15) the signal should be forwarded to. To do this, it uses the S0 - S3 pins to create the address that determines which output pin (electrode column) the signal should be send to. Why four pins? The multiplexer expects a binary signal. For instance, sending 0,0,0,0 to S0-S3 results in the output pin C0, vs. 0,1,1,0 sends the signal to C6. Let's implement this in the next section.<br><br>



<b>Setup Address Pins (S0-S3) as Digital Pins:</b> First, check which GPIO pin numbers you used for the multiplexer's S0 - S3 pins. Create the digital pins in your Arduino code and set the correct PinMode. <br><br>

<b>Compute the Bit Values for the Address Pins:</b> Fill out the "selectChannelOut(int channel)" function in the skeleton code. The function takes as input an 'int' for the channel number (0-8, since we have 9 sender lines in our 8x9 multi-touch pad) and then assigns the correct bit values to the 4 select pins (S0 - S3). Use 'digitalWrite' to write the correct value to each of the S0-S3 pins after you determined if they should be 0 or 1.<br><br>


<h3 id="SPI">(3) Receive Signals from Electrode Rows via SPI Communication</h3>

<b><i>**Note:</i></b> the Section (2) and (3) can be worked on independently, i.e. if you don’t get (2) to work you can still do (3) here. <br><br>

Remember from pset2 that we had wired up an additional ADC converter (MCP3008 chip) to get cleaner signals from our multi-touch pad, i.e. the MCP3008 chip converts our analog touch signals better than the ESP GPIO pins would be able to do. We had also discussed that the MCP3008 chip communicates with the ESP via the Serial Peripheral Interface (SPI) <a href="pset2-multitouch-assembly.html#RECEIVING">here</a>. To read the signals via SPI, you will have to do the following steps. <br><br> 

<b>Install MCP3008 Library</b>: Download and install the MCP3008 library by opening the Arduino IDE and going to Sketch -> Include Library -> Manage Libraries and search for the MCP3008 library. Restart your Arduino IDE after you installed the library.<br><br>

<img src="images/pset3/mcp3008-library.png" width="700px"> <br><br>

<b>Look at MCP3008 Example Code</b>: Go to File -> Examples and look at the bottom where it says 'Examples from Custom Libraries' to find example code that shows how to use the MCP3008 library. We recommend you look at the 'simpletest' example.<br><br>

<img src="images/pset3/mpc-library-examples.png" width="400px"> <br><br>

<b>Include Library</b>: As you can see in the simpletest example, you need to first include the library on top in the skeleton code.<br><br> 

<b>Instantiate Library</b>: After this, you need to declare an object of the library.<br><br>

<b>Open Communication Channel</b>: Next, you need to open the SPI communication channel with 'begin()'' in the setup function. However, we do not want to use the empty contructor begin() but instead also provide the pin numbers. You can see an example of this further down in the 'simpletest' example in the code that is commented out. Fill the pin numbers in according to your wiring.<br>

<!-- <img src="images/pset3/mpc-library-function.png" width="400px"> <br><br> -->
<pre>
	<code class="language-c">
		// Software SPI (specify all, use any available digital)
		// (sck, mosi, miso, cs);
		adc.begin(13, 11, 12, 10); // for ESP32, use (14, 13, 12, 25)
	</code>
</pre><br>


<b>Start reading signals</b>: Once the channel is open, you can read the signal from one of the input channels CH0-CH7 using the 'readADC(channelnumber)'' function (see the 'simpletest' example code). If you serial print the result, you should see your analog signal coming through.<br><br>

<b>Testing your Code:</b> You can check if the SPI communication between the ESP and the MCP chip works properly by doing the following: Connect a 3.3V output pin from the ESP to one of the MCP CH input channels and plot the result on the Serial Plotter.<br>
You should see a signal there around 1000. If you see '0' nothing is coming through and you either wired up the MCP chip incorrectly or you are reading from the wrong channel.<br><br>

<h3 id="Signals">(4) Injecting Signals into Columns and Reading Signals from Rows in the correct order</h3>

Now that you have code for telling your multiplexer to send the PWM signal to a specific electrode column, and you code for your ADC chip to read the signal from a specific electrode row, you are ready to write the meta-level code that tells your program when to inject into which electrode column and when to read which row.<br><br>

<b>Putting your Code in loop():</b> Since we will continuously read data from our multi-touch pad, your code should be in the 'loop()' function. <br><br>

<b>Inject Column #1, Read all Rows, Inject Column #2, Read all Rows...:</b> Your code needs to first send a signal through column #1, then read each row of the multi-touch pad one after another <span style="color:red">(rows #1-#9)</span>, and then continues to inject the signal into column #2, reads again <span style="color:red">row #1-#9</span> and so on.<br><br>

<b>Averaging Read Signals: </b> When reading the signal from a specific row, it helps to sample multiple times (e.g., execute read() 20 times and average them together) to get a more accurate and smooth signal. <br><br>

<b>Print Data to Serial Monitor:</b> Serial print the data in the format: columm0, row0val, row1val, row2val... A sample serial output could look like: <br>
<pre>
0,50,83,58,79,108,75,82,54   //columm0, row0val, row1val, row2val
1,55,92,120,84,63,61,88,53   //columm1, row0val, row1val, row2val
2,61,64,73,66,92,78,67,57
3,65,117,116,84,48,81,91,71
4,65,128,116,54,76,81,88,59
5,61,86,66,54,114,78,64,64
6,59,86,120,83,85,75,93,63
7,56,86,116,70,72,83,80,64
8,23,82,74,68,98,64,62,52
...
</pre> <br>

<b>Checking Result in Serial Plotter:</b> If you open up the Serial Plotter, it should look like the image on the left when the multi-touch pad is not touched, i.e. all values are roughly the same height. The middle shows a start of touching and the right the end of touching. <br><br>

<img src="images/pset3/multi-touch-pad-not-touch.png" width="250px"><img src="images/pset3/multi-touch-pad-touch-1.png" width="250px"><img src="images/pset3/multi-touch-pad-touch-2.png" width="250px"><br><br>

If you do not see these, please move on to the following "Debug Your Circuit" section and rule out some common errors first! <br><br>


<h3>Debug Your Circuit</h3>

If you do not see the above signals on your Serial Plotter, you can check the following parts of your circuit before coming to OHs for help. <br><br>

<b>Testing the Generated PWM signal:</b> If you want to test if you are generating the correct signal, <span style="color:red">we will have an oscilloscope ready at the IDC. If you know how to use an oscilloscope, you can come in and use it yourself outside the OH.</span> If you don't know how to use it, please come to an OH.<br><br>

<img src="images/pset3/oscilloscope.jpg" width="450px"><br><br>  

<b>Testing the Multiplexier Channel Select Function:</b> You can test if your channel selection function works properly in the following way: First, choose an output pin for testing from the C0-C8 output pins and set it in your function. Next, connect the SIG pin on Multiplexier to ESP32's 3.3V and use a multimeter to measure if the channel actually receives any voltage. Note that this is different than measuring resistance. Therefore, you need to set the multimeter into 'V' mode for measuring voltage, and then measure on the output pin and on GND. You should see 3.3V in the display. If you see 0, no voltage is applied and you need to debug your code to figure out why the pin is not receiving the signal.<br><br>

<img src="images/pset3/multimeter-v.png" width="250px"> <br><br>

<b>Tuning the Delay Function:</b> Note that in the skeleton code, there is a delay function. You may need to adjust the delay slightly depending on the amount of capacitive coupling your specific circuit layout has, which interferes and slows down the signal assign (e.g. digitalWrite()) slightly and can result in undefined behavior. The delay allows the multiplexer gets stable select pin values and assign correct output channel. Usually a delay of 2 - 5 milliseconds should be sufficient enough. <br>

<pre>
	<code class="language-c">
		//----- TODO: Set Select Pin Values -----
		void selectChannelOut(int channel) {
		    
		    // leave this delay at the end of the function,
		    // this is for mux to stabilize after each select pin values assignment
		    // you can adjust the delay value 
		    delay(2);  
		}
	</code>
</pre>
<br>

<b>Check Connections between Multitouch Pad and FPC Connectors:</b> Another thing to check is whether your multitouch pad is in good electrical connection to your circuit through FPC connectors. You can test this via a multimeter, please follow the <a href="pset2-multitouch-assembly.html#FPC">PSet2 Section (2)</a> for electrical connection test. <br><br>

If you still don't see the expected results from Arduino Serial Plotter, please come to an OH and one of our TAs will take a look with you together! <br><br>


<h3>Upload your Arduino Code</h3>

For grading, please upload the following to your google drive student folder:<br>

<ul>
	<li>the .ino file of your Arduino program</li>
	<li>2-3 photos showing your assembled circuit from different perspectives (include top view + side views)</li>
	<li>a short video showing the circuit working, i.e. show that touching the multi-touch pad produces a different signal than not touching the multi-touch pad. Make sure the Serial monitor and your multitouch pad are both visible at the same time.</li>
</ul>


<h3>Grading</h3>

We will give 20 pts in total:
<ul>
	<li>5 pts: does your code configure and generate the PWM signal correctly? Are the answers in the google form correct?</li>
	<li>5 pts: does your code correctly select the channel on the multiplexer to address the correct column?</li>
	<li>5 pts: does the ESP communicate with the MCP chip correctly via SPI?</li>
	<li>5 pts: is the receiver data read and recorded correctly?</li>
</ul>



        <br />
        <br />
      </section>

     <aside class="col-md-4 pull-left">
         <br /> <br /> <br /> <br /><br>

                 <h4 class="medium.headline" style="padding-bottom:10px;"><a href="pset-multi-touch-pad.html"><b>Pset Series: Multi-Touch Pad</b></a><br></h4>

<ul>
          <li><a href="pset1-circuit-design.html">Pset1: Generating the Fabrication Files</a></li>
          <li><a href="pset2-multitouch-assembly.html">Pset2: Assembling the Circuit</a></li>
          <li><a href="pset3-signal-processing.html">Pset3: Sensing Multi-Touch Input</a></li>
          <li><a href="pset4-visualization.html">Pset4: Visualizing Multi-Touch Input</a></li>
          <li><a href="pset5-multitouch-application.html">Pset5: Gesture Detection</a><br></li>
</ul><br>


<img src="images/pset-multi-touch-pad/pset-processing1.png" width="350px">
<br><br>

In this pset series, you will create an inkjet printed multi-touch pad. You will first write a Processing program that automatically generates the fabrication files for the multi-touch pad. Next, you will print your multi-touch pad, assemble it, and then build the circuit for sensing touch input. You will then write the microcontroller code for reading the touch signals from each electrode. Next, you will extend your code to draw the touch signals into an image and then extract the touch points via computer vision. Finally, you will write a gesture recognizer that can differentiate between different user inputs.<br><br>

</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>

      </aside>

    </div>
  </div>
  </div>
</section>

<div class="container">
	<div class="row">
		<div class="col-md-12 footer" style="text-align: center;">
			<span class="copyright">
			Since 2017 &copy; MIT CSAIL (HCI Engineering group) [redesign by
			<a href="http://punpongsanon.info/" target="_blank" style="text-decoration:none; border-bottom:0px">
			moji
			</a>].
			All Rights Reserved.

			<a href="http://mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/mit.svg" alt="MIT" class="footer-logo" />
			</a>
			<a href="http://csail.mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/csail.svg" alt="CSAIL" class="footer-logo"/>
			</a>
			<a href="http://hci.csail.mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/hci.svg" alt="HCI" class="footer-logo"/>
			</a>
			</span>
		</div>
	</div>
</div>

<!-- Bootstrap -->
<script type="text/javascript" src="../../js/bootstrap.min.js"></script>
<!-- header -->
<script type="text/javascript" src="../../js/headerstrap-for-subpage.js"></script>

</body>
</html>
