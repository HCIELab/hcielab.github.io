<!DOCTYPE html>
<html>
<head>
	<title>HCI Engineering Group</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

	<!-- CSAIL ICON -->
	<link rel="CSAIL" href="../../../images/icon/csail.ico" type="image/x-icon" />

	<!-- Bootstrap -->
	<link href="../../css/bootstrap.css" rel="stylesheet">
	<link href="../../css/custom-style.css" rel="stylesheet">

	<!-- jQuery -->
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

	<!-- Google Fonts -->
	<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Abel" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Barlow" rel="stylesheet">

	<!-- Google Analytic -->
	<script type="text/javascript" src="../../js/analytics.js"></script>

	<style>
	.etech-sch-col1 {width:60px; border: 1px solid black;padding:10px;}
	.etech-sch-col2 {width:120px; border: 1px solid black;padding:10px;}
	.etech-sch-col3 {width:450px; border: 1px solid black;padding:10px;}
	.etech-sch-col4 {width:70px; border: 1px solid black;padding:10px;}
  .etech-sch-col5 {width:70px; border: 1px solid black;padding:10px;}
  /*.etech-sch-col6 {width:170px; border: 1px solid black;padding:10px;}*/
  ul {
    padding:0px;padding-left:10px;margin:0px;
  }
	</style>
</head>

<body>
<header class="main_header">
	<!-- to be filled by javascript, see header.html -->
</header>

<section class="main_container">
	<div class="container">
    <div class="row nothing">

      <section class="col-md-8 pull-right main-content">
</br></br></br></br>
        <h4 class="medium.headline"><a href="6810-engineering-interactive-technologies.html">6.810 Engineering Interactive Technologies (fall 2020)</a><br></h>
        <h2 class="headline">Part 2: Connecting Micro-controller to UI</h2>
      
          <hr>

          <!-- Code in: Documents / Processing / SimpleRead --> 
          <!-- Code in: Documents / Arduino / serial-write -->
          <!-- Code in: Documents / Processing / SimpleWrite -->
          <!-- Code in: Documents / Arduino / serial-read -->

<h2 class="headline">Your Task for Today</h2>

In the last lab, we have already done steps 1-4 to get our interactive music card going.<br><br>

<b>(last lab) (1) Circuit Design:</b> You drew the circuit design of your card by creating a 2D drawing of the wires and interactive touch and slider areas.<br>
<b>(last lab) (2) Conductive Silver Inkjet Printing:</b> You printed your design with conductive inkjet printing.<br>
<b>(last lab) (3) Wiring up the Buttons:</b> You wired up your touch buttons using a breadboard and an ESP32 microcontroller.<br>
<b>(last lab) (4) Sensing the Touch Signals:</b> You sensed the touch signals using capacitive touch sensing (through Arduino's CapacitiveSensor Library) and applied filtering to the signals.<br><br>

Today, we are going to connect your card to Processing: When you push the physical touch button it will light up the corresponding digital touch button in Processing and the associated song will play. We will also extend the circuit and signal processing to include the touch slider for the music volume, which we haven't wired up yet.<br><br>

<b>(5) Visualizing User Input:</b> Next, you will setup the touch buttons <!-- and sliders --> in a programming environment called Processing, which will visualize when physical input on the touch buttons <!-- and sliders --> on screen and also play the corresponding songs. <br>
<b>(6) Wiring up and Visualizing the Slider:</b> Finally, you will add the slider to your circuit and user interface and use it to control the music volume.<br>

<h2 class="headline">Deliverables Lab 2 (due Friday, Sept. 11, 2020, 11.59pm)</h2>

At the end of Lab 2, upload to your student google drive:
<ul>
  <li>the Processing code (.pde) you wrote for Serial communication that displays the three touch bars and the slider bar</li>
  <li>the Processing code (.pde) of the completed music card application</li>
  <li>the Arduino code you wrote for Serial Communication (.ino file format) with the slider added</li>
  <li>a short video (.mov or .mp4, max. 1 minute) showing how you use each function of the printed music card, i.e. touch the buttons with your finger to play/pause a song, go to the previous/next song, and adjust the volume</li>
</ul><br>

<hr>


<h3 class="headline">(6) Wiring up and Visualizing the Slider for Volume Control</h3> <br>

Now that we have successfully wired up the touch buttons, processed the touch signals, and visualized them in Processing, we want to do the same three things for the touch slider.<br><br>

<h4>Connect the Physical Slider to the Main Circuit.</h4><br>

Start by wiring up each slider segment exactly the way how you wired up the individual touch buttons.<br>
Remember they can all use the same sender pin but need a different receiver pin.<br>
<a href="lab1-circuit-design-and-processing.html">Refer to Lab 1</a> if you don't remember how this works.<br><br>

Here is the pin out again for your reference.<br>
Remember, use the pins with "TOUCHX" labels for better signal quality but <b>do not use the one pin labeled as pin0 (TOUCH1) as receiver</b> (you can still use it as sender).
 <br><br>

<img src="images/esp32-pinout.jpg" width="600px" /><br><br>

<h4>Thresholding Slider Signals: How much is each segment touched?</h4><br>

Once finished with the wiring, extend the <b>Arduino code</b> so that it can also read each slider segment's touch signal.<br><br>

For the touch buttons, we were merely interested if the button is touched or not, thus we converted the touch signal into a <b>binary value 0 or 1</b> to indicated if it is pressed or not.<br>
Remember that for the slider we want to do something more sophisticated, i.e. have a continuous signal that allows us to smoothly adjust the music volume (rather than jumping from one discrete noise level to the next).<br>
Thus, each slider segment should return a <b>continuous value from 0.0 to 1.0</b> when touched depending on the area the finger overlaps with the slider segment.<br><br>

<img src="images/lab2-slider-segments.png" width="400px" /><br><br>

We can see by 'how much' a slider segment is touched by looking at the raw touch signals coming from the microcontroller.<br>
When looking at the Serial Plotter, you will notice that the raw value has a strong correlation with how much space of the slider segment is touched, i.e. the larger the area the higher the value is. <br><br>

You can thus calculate the continuous value from 0.0 - 1.0 by first determining the max value when the slider segment is fully touched and then checking how the returned value relates to this max value.<br>
We also recommend you only do the computation when the received value is above a certain minimum threshold to avoid noise.<br><br>

<img src="images/lab2-minimum-touch-threshold.png" width="600px" /><br><br>

For our example, we assume that each of your slider segments behaves the same, i.e. has the same threshold for being touched and the same max touch value. This should be the case since all of your slider segments have the same size, and while each has a slightly different wire length this should be negligible. In our example, we thus share the threshold values among all slider segments. If your slider segments have vastly different values (e.g. because of some damage to the slider segments' silver area), you need to create separate thresholds for each segment. You can check this by plotting each silder segments' raw values. <br><br>

Below: Individually touching each of the slider segments.<br>
<img src="images/lab2-slider-segments-raw-value.png" width="600px" /><br><br>

<b>Computing Global Slider Value</b><br>
Once you have the continous signal (0.0 - 1.0) for each slider segment, you need to compute the overall slider value.<br>
In our Arduino code, we can then write the overall slider value to the Serial port so that we can read it from Processing.<br><br>

The task here is to convert the five seperate slider segment values (all from 0.00-1.00) and combine them into one value that represents the overall slider position ranging from 0.00-1.00 (0-100 percent).<br><br>

<img src="images/lab2-slider-segments-global-value.png" width="400px" /><br><br>

For this, we will use some simple linear interpolation.<br>
We can also assume that at any given time, there will be at most 2 adjunct slider segments being touched (i.e. the user will only use one finger on the slider at any given time and the one finger will touch at max two adjacent slider segments since we made each segment roughly the size of the finger). <br><br>

<b>Assigning Slider Portions to Percentage Values</b><br>

Since we have 5 slider segments in our example, one could say that each slider segment is representing 20% (0.2) of the overall music volume.<br>
Thus, when we know slider segment 2 is touched, it must be a music volume between 20-40%.<br>
To figure out the exact value between 20-40%, we can then look at the slider segments value.<br><br>

However, because we have overlapping slider segments, looking at each segment individually actually doesn't help us very much to compute one global continous value.<br>
Instead, we need to consider two adjacent segments since they will almost always be touched together.<br>
To be able to consider adjacent segments, we therefore split the slider into 4 segments that overlap with each other as shown below. Each overlapping segment thus represents 25% of the overall volume.<br>
If we only touch the first or only touch the last segment, we assume we are at 0% or 100%.<br><br>

<img src="images/lab2-slider-segments-overlap-segments.png" width="400px" /><br><br>


<!-- <b>Global Slider Value When Only One Slider Segment is Touched</b><br>
Let's look at the most easy example, i.e. only one slider segment is touched.<br>

Let's assume, we read a value of 0.2 from the slider segment 3, we can then conclude that we are at 1/5th of the overall range from 40-60%, i.e. 1/5th of 20 = 4, 40% + 4% = 44%). <br><br>

Thus, when only one slider segment is touched, we can calculate the overall slider value based on:<br> 
1) the touched slider segment's order (0 to 4 representing 0-20%, 20-40%, 40%-60%, etc.) <br>
2) the touched slider segment's value (0.00-1.00 representing intermediate values) <br> <br>
 -->
<!-- We can you the following formula:
 -->
<!-- <b> slider_value = slider_segment_value * 0.2 + slider_segment_order * 0.2 </b>, e.g. the second slider segemnt touched with the value 0.80, the overall slider value would be 0.80 * 0.2 + 1 * 0.2 = 0.36; the third slider segemnt touched with the value 0.80, the overall slider value would be 0.80 * 0.2 + 2 * 0.2 = 0.56. <br><br> -->

<b>Global Slider Value When Two Slider Segments are Touched</b><br>

Consider what happens as we slide from left to right from slider segment 2 towards slider segment 3.<br>
First, the slider value of segment 2 will get higher as more and more area of our finger overlaps with the slider segment.<br>
Then, as we move towards the slider segment 3, the value of slider segment 2 decreases again as more and more of our finger leaves the slider segment 2 and instead overlaps with the slider segment 3.<br>
Thus, once we know that the finger touches the slider segment 3, a lower sensor value of segment 2 actually means a higher slider value and not a lower one!<br>
To compensate for this, if we detect that segment 3 is touched, we subtract the segment 2 slider value from 1.0.<br>
e.g. segment2 = 0.25 && segment3 is touched then segment2 = 1.0-0.25 (results in 0.75).<br>
For slider segment 3, we can simply read the regular value and use it.<br><br>

Next, we still have to map the two slider values to an overall slider value.<br>
For this, we first compute the mean of both values ((0.75+0.78)/2 = 0.765) and then map the resulting number onto the value range of the slider volume area (i.e in our example the area we are looking at is from 25%-50% since this covers both slider segment 2 and 3). Since the slider volume slider area is 25-50% and we are at 76.5% between these values, the final slider value is 25%+((50-25)*0.765) = 44.125% as the final slider value. <br><br>

<img src="images/lab2-slider-segments-final-value.png" width="400px"><br><br>

Next, we need to write the final slider value to the serial part.<br>
For the calculated slider value, format the output like we did before for the touch button so that:

<code>(sensor ID),(slider_value);</code><br><br>
    
(sensor ID) is 3, and represents the ID of the slider (we already used up sensor IDs 0, 1, 2 for the touch buttons).<br>
(slider_value) is ranging from 0.00 to 1.00 to indicate the overall slider position (music volume).<br><br>

A sample output hould look like:<br>
<pre><code>3,0.78;
3,0.86;
3,0.97;
</code></pre> 
The output should print continuously as long as the slider is touched. <br>

<br>

<h4>Create Slider Visualization</h4><br>

Now that the slider values are printing to the Serial port, we can read them from Processing.<br>
Open your Processing program that had the three touch bars and add a horizontal bar for the slider.<br> 
The bar represents the entire slider. Thus, if the finger is on the left side of slider, the bar should be short and if the finger slides more to the right side of the slider, the bar should be long.<br><br>

<img src="images/lab2-slider-visulization-low.png" width="300px">
<img src="images/lab2-slider-visulization-high.png" width="300px"><br><br>

<h4>Add Slider onto the Card</h4><br>

Now that you know the slider values can be visualized in Processing, let's add it to the music card to control the music volume.<br> Open the music card code again.<br><br>

We already implemented a class 'Slider' for you.<br>
You can make a new slider with:<br><br>

<pre><span style="red">mySliders.add(new Slider(start_x, start_y, end_x, end_y));</span></pre>

Please add one slider to the code, just like how you added the button. <br>
Add code to the draw() function to display the slider when it is not in "hide" mode.<br><br>

Your result should look like this.<br>
You should be able to control the slider by dragging your mouse (with left mouse button pressed): <br><br>

Dragging the mouse on the slider from left to right:<br>
<img src="images/lab2-volume-low_UI_new.png" width="350px">
<img src="images/lab2-volume-middle_UI_new.png" width="350px">
<!-- <img src="images/lab2-volume-high_UI.png" width="200px"> -->
<br><br>

<h4>Create Slider Events for the Music Volume Control</h4><br>

To create events on mouse drag, we need to implement several mouseDragged() events.<br>
We already did some parts of it for you in the code further down in the class.<br>
Please go ahead and extend the code so that it changes the music volume based on the slider level. <br>
You might find the following functions from the "Audio" and "Slider" classes useful: <br>
<br><pre>
music.changeVolume(double intensity);
Slider.getIntensity();</pre><br><br>

Once you finished your code, test if the music volume actually changes by first playing a song with the virtual touch button and then dragging the slider to adjust the music volume. If everything works, move on.<br><br>

<h4>Hide the Slider</h4><br>

Similar to the previously added buttons, you can hide the Slider by pressing the 'h' key on your keyboard while your program runs.<br>
If you want to see them again, press 's' (for show).<br><br>

<h4>Now Let's Change Music Volume from the Inkjet Printed Physical Card</h4><br>

Now that we can control the slider digitally, we also want to adjust the volume of the music from the physical card.<br><br>
Copy over your code that reads the slider value for the Serial Port from the other Processing application you just wrote and integrate it into the music card.<br>

<img src="images/lab2-volume-low_new.png" width="350px">
<img src="images/lab2-volume-middle_new.png" width="350px">
<!-- <img src="images/lab2-volume-high_UI.png" width="200px"> -->
<br><br>

Now test if everything works by using your physical printed card to play/pause songs and the physical slider to adjust the music volume. If it works, congrats, you are done :)!<br><br>

<h2 class="headline">Deliverables Lab 4 (due Friday, Sept. 11, 2020, 11.59pm)</h2>

At the end of Lab 4, upload to your student google drive:
<ul>
  <li>the Processing code (.pde) you wrote for Serial communication that displays the three touch bars and the slider bar</li>
  <li>the Processing code (.pde) of the completed music card application</li>
  <li>the Arduino code you wrote for Serial Communication (.ino file format) with the slider added </li>
  <li>a short video (.mov or .mp4, max. 1 minute) showing how you use each function of the printed music card, i.e. touch the buttons with your finger to play/pause a song, go to the previous/next song, and adjust the volume</li>
</ul><br>

    
<!--   This means that when touching one of the touch buttons, your ESP should send a message to your computer that the Processing script can understand and change its background color.
 -->

<!--  In particular, we are going to wire up a button, and when the button is pressed, we will show this in Processing by coloring the corresponding button in the digital UI and starting a song.<br><br>
<!--
<h4>Replacing the Standard Button with your Printed Touch Button</h4><br>

We hope you received your custom touch button from last week. If not, your original package has a standard printed touch button (square) that you can use instead.<br><br>

We are now going to replace the standard touch button with your custom touch button.<br>
First, use the multimeter to check if you touch button is conductive and didn't break during transport.<br>
If you don't remember how to use the multimeter, check last week's tutorial.<br><br>

<img src="images/multimeter.jpg" width="300px"><br><br>

Ok, if your multimeter shows low resistance, we are ready to wire up your touch button.<br>

<b>Electronics:</b> To build the circuit to implement touch sensing you only need your touch sensor and one resistor (say some more why this is necessary). Low resistors (1kOhm - 100kOhm) are mostly used for sensing touch (see Figure below).<br><br>

<img src="images/touch-sensing-principle.png" width="300px"> <img src="images/touch-sensing-circuit.png" width="300px"><br><br>

<img src="images/touch-sensor-on-breadboard.jpg" width="300px"> <img src="images/touch-sensor-on-breadboard-schematic.png" width="300px"><br><br>

<b>Connecting the Touchbutton to the microcontroller:</b> To connect the touch button to the microcontroller and remaining electronics, we are going to use conductive tape. Cut a piece of conductive tape and attach it to the connector pad and then to the end of a wire that goes to the microcontroller (would be great to have the break out board so this is less messy).<br><br>

<b>Code:</b> Once you build your circuit, you can write the code to read input from your touch sensor. Capacitive touch sensing is luckily already supported by the Arduino Toolkit.<br><br>

Download the latest <a href="https://github.com/PaulStoffregen/CapacitiveSensor"> library CapacitiveSensor for Arduino from here</a> and place it into your Documents / Arduino / Libraries folder (unzip it and rename it to 'CapacitiveSensor'). Restart your Arduino software, otherwise the library is not recognized.<br><br>

First you need to import the library:<br>  
<code>#include CapacitiveSensor.h</code><br>  <br>  

Next, you need to create a new CapacitiveSensor object:<br>  
<code>CapacitiveSensor sensor1 = CapacitiveSensor(sender, touch_pin_1);</code><br>  
It takes as input the pin that has the high signal and the receiver pin.<br><br>  

In the loop function, you are now ready to read from the sensor.<br>  <br>  

<code>double analog_touch = sensor1.capacitiveSensor(samples_touch);</code><br>  
The argument <b>samples</b> defines the sensitivity of the sensor.<br>  <br>  
For touch sensing a low sensitivity is common with samples between 1 and 20. <br><br>

If you print analog_touch to the Serial monitor and you touch your touch button, you should be able to see the values change quite drastically. Do some simple thresholding to determine when the button is pushed and when it is not pushed (e.g., values above XX equal pushed, values below XX equal unpushed). <br><br> 

<div style="background:#04a47c;padding:10px;">Checkoff 2: Show your working touch sensor that when pushed, prints 'pushed' to the Serial monitor and otherwise prints 'unpushed'.</div><br>

 <h3 class="headline">Performing Input in Processing<br> and Using it on the Microcontroller</h3>

Let's do it the other way around and write some output from Processing onto the microcontroller.<br>
In our simple example, we will light up an LED when the user clicks a button in the Processing UI, and then later replace it with our printed EL display.<br><br>

<h4>Wiring Up an LED and Write Basic On/Off Code</h4>

Let's start by wiring up an LED on the breadboard and writing the basic code to turn the LED on/off. <br>
If you haven't coded in Arduino for a while, you may want to look at 'Examples -> Blink' to see how to read input from a pin and turn your LED on/off.<br><br>

<img src="images/led-on-breadboard.jpg" width="250px"> <img src="images/led-on-breadboard-schematic.png" width="350px"><br><br>

<h4>Create Microcontroller Script that Reads from Serial Monitor</h4>

Once you confirmed that your LED works (i.e. you tested it turns on), we will now write a piece of Arduino code that will listen to the Serial communication and whenever it encounters a '2' it will light up the LED and when it encounters a '3' it will turn the LED off.<br><br> 

This part is very similar to the previous Arduino code, just that instead of Serial.write() you are now going to use <a href="https://www.arduino.cc/reference/en/language/functions/communication/serial/read">Serial.read()</a> to determine if a 2 or 3 was send and the LED should be on or off.<br><br>

Complete the rest of the Arduino script for turning on/off your LED by reading from the Serial connection and upload it to the microcontroller.<br>
We will test this in a moment when we connect it to Processing.<br><br>

<h4>Create Processing Script that Writes to Serial Monitor</h4>

Once you uploaded your Arduino code, we are now ready to write a Processing script to write to the serial connection the '2' or '3' values, which can then be used by the Arduino code to decide if the LED should be on or off.<br>
Whenever a button is clicked in the Processing UI, we want to write a '2', otherwise a '3'. <br><br>

The setup code is the same as in the previous Processing example above, but now you are using<br>
<code>myPort.write(2); // 2 or 3 depending on state</code><br><br>

        <!--
    
<h4>Blinking LED to Beat</h4><br>

To blink the LED to the beat, we prepared this custom Processing script for you.<br>
All you need to do is to send a '2' or '3' whenever our script tells us that the beat just happened.<br>

<div style="background:#04a47c;padding:10px;">Checkoff 3: Show your working LED that can be turned on by pushing the button in Processing and can also blink to the beat of a song.</div><br><br>

<h4>Replacing the Standard LED with your Printed Display</h4><br>

With that information in mind, we are now ready to connect your EL display to the microcontroller.<br>
First, use the multimeter to check if your display is conductive and didn't break during transport.<br>

<img src="images/multimeter.jpg" width="300px"><br><br>

Ok, if your multimeter shows low resistance, we are ready to wire up your EL display.<br>

<b>Electronics:</b> To light up your EL display, you need to build the following circuit (add more information here).<br><br>

<b>Connecting the Display to the microcontroller:</b> To connect the display to the microcontroller and remaining electronics, we are going to use conductive tape. Cut a piece of conductive tape and attach it to the connector pad of the display and then to the end of a wire that goes to the microcontroller (would be great to have the break out board so this is less messy).<br><br>

<img src="images/touch-sensing-circuit.png" width="300px"><br><br>

<b>Code:</b> Once you build your circuit, you can write the code to light up your EL display (add more information here). <br><br>

    
<h4>Connecting EL Display to Processing</h4><br>

Now that you know your EL display is working properly, you can make it light up based on the information coming from the Serial communication, i.e. the beat of the song. Replace the hard coded on/off for the EL display with the '2' or '3' date you are reading from the Serial monitor. <br><br>


<h2 class="headline">Miniatiarizing the Microcontroller</h4>

Right now, we are using a pretty big and clunky microcontroller, which doesn't integrate well with our design.<br>
In the final step today, we want to replace the big microcontroller with a smaller one: the ATTiny.<br>

<img src="images/attiny.jpg" width="300px"><br><br>

Looking at this image, you may have a few questions, such as how to know which pin is which since nothing is labeled and how to program the thing since there is no space for a USB cable connection!<br><br>

<h4>Identifying Pins on the ATTiny</h4><br>

To find our which pin is which, you first need to know where is the top left corner of the Attiny. If you look very closely, you can see a small dot on the top black surface. The small dot indicates the top left corner of the controller. Once you know which corner is the top left, you can search for the <a href="https://components101.com/microcontroller/attiny85-pinout-datasheet">data sheet of the ATTiny on google</a>.<br><br>

<img src="images/attiny-top-left.png" width="200px"> <img src="images/attiny-datasheet.png" width="350px"><br><br>

Ok great, so now you know where VCC and GND are and where the data pins are for analog and digital communication.<br>
However, the question still remains, how to upload code.<br><br>

<h4>Uploading Code to ATTiny</h4><br>

There are several different ways how to program an ATTiny, one of the most straight forward is to use a device, such as the Tiny Programmer, see below.<br>

<img src="images/attiny-programmer.png" width="200px"> <br><br>

To program your ATTiny, you simply put it in the slot with the breadboard pins.<br>
In the next step, you then connect jumper wires to go from the connecting pins to your breadboard.<br>
You can use the USB connection on the Tiny Programmer to connect to your laptop.<br>

<img src="images/tiny-programmer-in-action.png" width="500px"> <br><br>

Once you confirmed that your code is correct and everything is working, you can move the ATTiny off the Tiny Programmer and put it onto your breadboard where it will keep looping its code there to perform its function.<br><br>

<h4>How to get Rid of the Breadboard? SMD Components. </h4><br>

Ok so this is already better than before, but still not great because we still have the breadboard there.<br>
So far, you have used for the ATTiny is called a DIP (dual inline package) that has two rows of pins that needly fit into a breadboard. To make it even smaller, you can get the same ATTiny as an SMD (surface mount device), which means it will not have pins but instead needs to be soldered onto a PCB.<br><br>

To produce the ATTiny as an SMD on a PCB, we used (this PCB manufacturing facility) and gave them (this specification) and (these design files). As a result, we got the following SMD component back.<br><br> 

<img src="images/attiny-smd.jpg" width="300px"> <br><br>

Ok, so now we are back at square one, how do we program the thing? Since it doesn't have pins anymore, it doesn't fit into the Tiny Programmer.<br>
Lucky for us, there is <a href="https://www.amazon.com/gp/product/B00HHH65T4/ref=ppx_yo_dt_b_asin_title_o00_s00?ie=UTF8&psc=1">another device for this</a> that you can see below.<br><br>

<img src="images/attiny-testclip.png" width="300px"> <br><br>

To use it, you clamp the front onto your ATtiny.<br>
Then you use jumper wires to connect the upper part back to the Tiny Programmer (Stefanie: I will try this out and update here once I know more).<br><br>

<img src="images/attiny-testclip2.png" width="300px"> <br><br>

<h4>Attaching the SMD Microcontroller to the rest of the Circuit with Z-Tape</h4><br>

Now that we have programmed the ATTiny PCB, we can attach it to our card.<br>
If you flip your ATTiny and look at the back you can see that we create the PCB as a double-sided PCB, i.e. the connections extend all the way to the back.<br><br>

<img src="images/attiny-front.jpg" width="300px"><img src="images/attiny-back.jpg" width="300px"> <br>
Front and back of the ATtiny PCB.<br><br>

We can now use z-tape and attach it to the back of the PCB.<br>
ztape is a special tape that conducts vertically but isolates horizontally.<br>
Once the ztape is on, you can peel back the other side of the ztape layer and attach it to your card.<br>
(Stefanie: If we want to do this part, we need to ask them to redraw their wire connections so they fit the ATTiny and not the ESP32. Perhaps this could be a good moment to use the silver pen?)<br><br> 

-->

<!--  <h3 class="headline">Bringing it all together</h3>

 -->



        <br />
        <br />
        <br />
      </section>

      <aside class="col-md-4 pull-left">
         <br /> <br /> <br /> <br />
<!-- 				 <h4>Pset Steps</h4><br>
				 <ul>
		 			<li><a href="#pset1">pset1 (due Sept. 21, 11.59pm): laser cut and bend the acrylic base</a><br /></li>
		 			<li><a href="#pset2">pset2 (due Oct. 5, 1pm): insert LEDs, add USB connecting and solder everything</a><br /></li>
		 			<li><a href="#pset3">pset3 (due Oct. 19, 1pm): write touch recognition so that you can determine (x,y) location of each finger</a><br /></li>
		 			<li><a href="#pset4">pset4 (due Oct. 26, 1pm): add an application of your choice</a><br /></li>
				</ul>
				<br /> <br /> <br /> <br />
        <img src="../2018-fall-6810/images/multi-touch-pad/iap1.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad/iap2.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad//iap3.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad/iap4.jpg" width="220px">

		<img src="../2018-fall-6810/images/multi-touch-pad/iap5.jpg" width="220px">
 -->



        <!-- Publication -->

        <br><br><br><br><br>

        <!-- Publication -->

<!-- <h4>Side Bar</h4><br>

    <ul>
      <li>Prof. Stefanie Mueller (Instructor)</li>
      <li>Lotta-Gili Blumberg (TA)</li>
      <li>Xin Wen (UTA)</li>
      <li>Loren Maggiore (LA)</li>
      <li>Mark Chounlakone (LA)</li>
    </ul>
 -->
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>

      </aside>

    </div>
  </div>
  </div>
</section>

<div class="container">
	<div class="row">
		<div class="col-md-12 footer" style="text-align: center;">
			<span class="copyright">
			Since 2017 &copy; MIT CSAIL (HCI Engineering group) [redesign by
			<a href="http://punpongsanon.info/" target="_blank" style="text-decoration:none; border-bottom:0px">
			moji
			</a>].
			All Rights Reserved.

			<a href="http://mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/mit.svg" alt="MIT" class="footer-logo" />
			</a>
			<a href="http://csail.mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/csail.svg" alt="CSAIL" class="footer-logo"/>
			</a>
			<a href="http://hci.csail.mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/hci.svg" alt="HCI" class="footer-logo"/>
			</a>
			</span>
		</div>
	</div>
</div>

<!-- Bootstrap -->
<script type="text/javascript" src="../../js/bootstrap.min.js"></script>
<!-- header -->
<script type="text/javascript" src="../../js/headerstrap-for-subpage.js"></script>

</body>
</html>
