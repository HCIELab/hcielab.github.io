<!DOCTYPE html>
<html>
<head>
	<title>HCI Engineering Group</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

	<!-- CSAIL ICON -->
	<link rel="CSAIL" href="../../../images/icon/csail.ico" type="image/x-icon" />

	<!-- Bootstrap -->
	<link href="../../css/bootstrap.css" rel="stylesheet">
	<link href="../../css/custom-style.css" rel="stylesheet">

	<!-- jQuery -->
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

	<!-- Google Fonts -->
	<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Abel" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Barlow" rel="stylesheet">

	<!-- Google Analytic -->
	<script type="text/javascript" src="../../js/analytics.js"></script>

	<style>
	.etech-sch-col1 {width:60px; border: 1px solid black;padding:10px;}
	.etech-sch-col2 {width:120px; border: 1px solid black;padding:10px;}
	.etech-sch-col3 {width:450px; border: 1px solid black;padding:10px;}
	.etech-sch-col4 {width:70px; border: 1px solid black;padding:10px;}
  .etech-sch-col5 {width:70px; border: 1px solid black;padding:10px;}
  /*.etech-sch-col6 {width:170px; border: 1px solid black;padding:10px;}*/
  ul {
    padding:0px;padding-left:10px;margin:0px;
  }
	</style>
</head>

<body>
<header class="main_header">
	<!-- to be filled by javascript, see header.html -->
</header>

<section class="main_container">
	<div class="container">
    <div class="row nothing">

      <section class="col-md-8 pull-right main-content">
</br></br></br></br>
        <h4 class="medium.headline"><a href="6810-engineering-interactive-technologies.html">6.810 Engineering Interactive Technologies (fall 2021)</a><br></h>
        <h2 class="headline">Part 2: Connecting Micro-controller to UI</h2>
      
          <hr>

          <!-- Code in: Documents / Processing / SimpleRead --> 
          <!-- Code in: Documents / Arduino / serial-write -->
          <!-- Code in: Documents / Processing / SimpleWrite -->
          <!-- Code in: Documents / Arduino / serial-read -->

<h4>Serial Communication to Send Touch Signals to Processing</h4><br>

It then communicates the sensor signals in the format we defined back to our laptop using Serial communication through the USB cable.<br>
So far, we have only used the Arduino IDE to 'listen' to the Serial communication from the USB cable and to show the values in the Serial Monitor or the Serial Plotter.<br>
However, since any software can listen to the Serial Communication, we can also write programs in other programming languages and IDEs to read and do something with the sensor signals.<br><br>

In the next lab, we are going to write a program in Processing.<br>
Processing is a programming environment that makes it very easy to built on-screen UIs.<br>
For our purposes, we will build a digital version of our music card that will highlight the corresponding areas on the card when you push the button on the physical card and will also play the corresponding song.<br>

<h2 class="headline">Your Task for Today</h2>

In the last lab, we have already done steps 1-4 to get our interactive music card going.<br><br>

<b>(last lab) (1) Circuit Design:</b> You drew the circuit design of your card by creating a 2D drawing of the wires and interactive touch and slider areas.<br>
<b>(last lab) (2) Conductive Silver Inkjet Printing:</b> You printed your design with conductive inkjet printing.<br>
<b>(last lab) (3) Wiring up the Buttons:</b> You wired up your touch buttons using a breadboard and an ESP32 microcontroller.<br>
<b>(last lab) (4) Sensing the Touch Signals:</b> You sensed the touch signals using capacitive touch sensing (through Arduino's CapacitiveSensor Library) and applied filtering to the signals.<br><br>

Today, we are going to connect your card to Processing: When you push the physical touch button it will light up the corresponding digital touch button in Processing and the associated song will play. We will also extend the circuit and signal processing to include the touch slider for the music volume, which we haven't wired up yet.<br><br>

<b>(5) Visualizing User Input:</b> Next, you will setup the touch buttons <!-- and sliders --> in a programming environment called Processing, which will visualize when physical input on the touch buttons <!-- and sliders --> on screen and also play the corresponding songs. <br>
<b>(6) Wiring up and Visualizing the Slider:</b> Finally, you will add the slider to your circuit and user interface and use it to control the music volume.<br>

<h2 class="headline">Deliverables Lab 3 (due Friday, Sept. 11, 2020, 11.59pm)</h2>

At the end of Lab 3, upload to your student google drive:
<ul>
  <li>the Processing code (.pde) you wrote for Serial communication that displays the three touch bars and the slider bar</li>
  <li>the Processing code (.pde) of the completed music card application</li>
  <li>the Arduino code you wrote for Serial Communication (.ino file format) with the slider added</li>
  <li>a short video (.mov or .mp4, max. 1 minute) showing how you use each function of the printed music card, i.e. touch the buttons with your finger to play/pause a song, go to the previous/next song, and adjust the volume</li>
</ul><br>

<hr>


<h2 class="headline">Make sure everything from last lab is still working</h2>

Before getting started with the new content, let's first make sure everything from last time is still working and no wires came lose.<br> 
To do this, connect your music card and ESP32 again to your computer via USB and upload the Arduino program that you haven written in the last lab.<br> 
Double check that everything is still working, i.e. when touching one of the touch buttons you should see the touch signals show on the Serial monitor.<br><br>

<hr>

 <h3 class="headline">(5) Visualizing User Input with Processing</h3><br>


<h4>Receiving Touch Input in Processing:<br> Create Processing Script that Listens to Serial Communication</h4><br>

In the last lab, we sent the touch input to the Arduino IDE and plotted it in the Serial Monitor or Serial Plotter.<br>
Since Arduino has no libraries for graphical user interfaces, we now want to instead send our touch input to Processing.<br>
<br>

<a href="https://processing.org" target="_blank">Processing</a> is a user interface protoyping platform that is based on Java. It was created by MIT students (and others) in their spare time starting in Spring 2001 and is nowadays used by thousands of makers and UI designers. You can find useful information on how to use it in their <a href="https://processing.org/tutorials/" target="_blank">tutorial section</a>.<br><br>

In the last lab, we encoded a touch event in the format:<br><br>

<code>(sensor ID),(is_touched)(newline)</code><br><br>
    
(sensor ID) is either 0, 1 or 2 and represents the ID of the observed touch sensor.<br>
(is_touched) is either 0 or 1 (0 if the sensor is not touched, and 1 if it is touched).<br><br>

And wrote it to the Serial port using <code>Serial.print()</code>.<br><br>

The resulting messages looked like this:<br><br>

If sensor 0 gets touched, this message is printed once:<br>
<pre><code>0,1;</code></pre>

Then when the user lifts the finger again, this message is printed once:<br>
<pre><code>0,0;</code></pre>

To use this information in Processing for our graphical user interface, we need to write a Processing script that listens to the Serial communication.<br><br>

To do this, open Processing, create a new program, and import the <a href="https://processing.org/reference/libraries/serial/index.html">Serial library</a>.<br>
<pre>import processing.serial.*;</pre><br>

Next, you need to create a new port that can be used for communication by creating an object from this class: <br>
<pre>Serial myPort;</pre><br>

To create the port, you need to define three things: (1) you need to tell the port which application will listen to it (i.e. 'this' one), (2) you need to tell the port its portname (same as you used in Arduino), and (3) you need to tell the port at which baudrate it should listen to be able to decode the messages (same as you used in Arduino). <br><br>

<pre>myPort = new Serial(this, portName, baudrate);</pre><br>
    
For the <code>portName,</code> you can get a list of all available ports from the Serial library (see below).<br> 
By accessing different buckets of the list, you can get access to the name of each port.<br>
The correct port is the one you also used in your Arduino program, i.e. this is where the microcontroller is connected to your laptop.<br>
Check if the correct portname is in bucket 0, 1, or 2 by printing it.<br><br>

<pre>// check which port you use: 0, 1, 2?
String portName = Serial.list()[2];
print(portName);</pre><br>

For the <code>baudrate</code>, you also already know this from your Arduino program that you uploaded to the microcontroller.<br>
Check in your Arduino program with which baudrate you initialized the Serial communication.<br>
If you use a different baudrate than you wrote into the Arduino program, you will only get a lot of random stuff back since your Processing application will not know how to 'translate' the messages that are coming from the microcontroller since it would 'speak' at a different frequency than the Processing application would 'listen'.<br><br>

Now that your port is defined, we are ready to listen to it and check if data is available, but before we do this let's briefly look at the Processing program structure.<br><br>

<h4>Processing Program Structure: setup() and draw() functions</h4><br>

Similar to Arduino, every Processing program has two functions: one that is run only once (setup()) and one that is looping forever (draw()).<br><br>

Before we move to the next step, let's create a setup function:<br><br>

<pre>
void setup() { // runs only once
  
}
</pre><br>

Move the port constructor code into the setup() funtion since we only need to construct the port once.<br><br>

Next, create an empty draw function:<br><br>

<pre>
void draw() { //runs infinitely
  
}
</pre><br>

We are going to fill this in the next step with the code that will continously listen to the port and see if any new messages are there from the microcontroller.<br><br>

<h4>Reading Data from the Serial Port</h4><br>

Now that we have the port defined, we can see if data is available and if the answer is yes, we can read the data from the port.<br>
In the draw function, add the following lines:<br><br>

<pre>
// If there is a message with at least 4 characters 
// remember we are sending in the format: <i>sensorNumber comma touched semicolon</i> with one character each
if (myPort.available() >= 4) { 

    // read a String until the character ';' is found, which indicates the end of our message
    String val = myPort.readStringUntil(';'); 
  }</pre><br>

Note that we use <code>myPort.readStringUntil()</code>, which we can do because we are sending a string on the serial port from our Arduino program that is looping on the microcontroller. If we send other data-types, we would have to use a different function so Processing knows how to convert the un-typed data that is coming through the port at the specific baudrate.<br><br>

Next, check if this is working. We recommend you <a href="https://processing.org/reference/print_.html">print()</a> the String value to the Processing command line, run your Processing program, and touch your touch sensor to see if the statements you printed to Serial port (via Arduino IDE) gets printed on the Processing command line. If you are getting a ‘port busy’ error, make sure you close the Serial Monitor / Plotter on Arduino IDE. <br>
If that doesn't work, now would be a good moment to get some help.<br><br>

<h4>Creating a Visualization for the Incoming Touch Sensor Data</h4><br>

Now we can do something based on the incoming Strings.<br>
In the next step, we want to create a bar that goes up if the touch sensor is touched and down if the sensor is not touched.</br>
Let's start with a single bar for touch sensor 1 and we can do the rest later.<br><br>


<img src="images/lab3/lab2-bar-down.png" width="300px">
<img src="images/lab3/lab2-bar-up.png" width="300px"><br>

Let's first create the bar with a fixed width of 100px and a fixed height of 300px.<br>
Here are some useful references:<br><br>

For setting the size of your application window:<br>
<ul>
  <li><a href="https://processing.org/reference/size_.html">size()</li>
</ul>
<br>

For drawing the rectangle:<br>

<ul>
  <li><a href="https://processing.org/reference/rect_.html">Rect</a></li>
  <li><a href="https://processing.org/reference/rectMode_.html">RectMode</a></li>
</ul>
<br>

For coloring the bar and the background:<br>
<ul>
  <li><a href="https://processing.org/reference/fill_.html">Fill</a></li>
  <li><a href="https://processing.org/reference/background_.html">Background</a></li>
</ul>

<br>

Once you are done it should look like this:<br><br>

<img src="images/lab3/lab2-bar-up.png" width="300px"><br>

Next, we can connect the height of the bar to the incoming touch sensor data coming from the serial messages in our Processing Script.<br>
But before we can do this, we first have to do some String Processing on the incoming message since the message is still a single string in the format of e.g., <pre><code>0,1;</code></pre> Therefore, we need to split up the message.<br><br>

<h4>Splitting the Incoming Message String into Individual Values</h4><br>

What we are currently printing to the command line are String in the format of "0,1;" (sensor_ID,is_touched;).<br>
However, to analyze this data in our code we have to split it again into two individual values so we can check the sensor_ID and and if the sensor is touched or not with an if/else statement.<br><br>

Use the String split() function to do that.<br>
You can find information on split() and how to use it in the <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html" target="_blank">Java String reference</a>.<br>
Once you have both the <code>sensor_ID</code> and <code>is_touched</code> separated, we recommend you check that this worked by printing them to the command line before moving on.<br><br>

<h4>Connecting the Incoming Touch Signals to the Visualization</h4><br>

Next, we will connect the height of the bar to the incoming touch signal.<br>
A high bar shows that the sensor is being touched.<br>
A low bar shows that the sensor is not being touched.<br><br>

<b>Tips</b>
<ul>
  <li>If you plan to use a boolean in Processing, the datatype is spelled out <code>boolean myVariable;</code> not <code>bool</code> like in Arduino.</li>
  <li>If you do a String comparison, remember you cannot use <code>stringVariable == "StringValue"</code>, instead you need to use <code>equals()</code>, check the reference here <a href="https://processing.org/reference/String_equals_.html">equals()</a></li>
  <li>Don't forget to clear the background at the beginning of the draw() function. Otherwise, you are just drawing each update on top of the previous update, so you may actually not see the bar changing since a shorter bar overlaid over a longer bar is not visible. Use <code>background(255,255,255);</code> or any other color you like.</li>
</ul>

<br>

Once you are done, it should look like this:<br><br>

<img src="images/lab3/lab2-touched-not-touched.png" width="600px"><br><br>
 
<h4>Extend Visualization to Three Bars</h4><br>

Next, we want to extend our user interface to have a bar for all three touch sensors.<br>
It should look like the image below.<br><br>

Only touch button 1 is touched, touch button 2 and 3 are not touched.<br>
<img src="images/lab3/lab2-three-bars-one-touched.png" width="300px"><br><br>

Touching multiple touch sensors simultaenously also works.<br>
This should be a bit surprising to you, since we can only read one message at a time in the draw() function.<br>
The reason it still works is that we are reading messages at such a high speed that the processing gap is not visible to the human eye.<br><br>

Only touch button 1 and 2 are touched, touch button 3 is not touched.<br>
<img src="images/lab3/lab2-three-bars-multiple-touched.png" width="300px"><br><br>


<!-- We created a Processing script for you that has the bars already implemented but lacks the Serial Communication.<br> -->
<!-- You can download the script here: <a href="images/lab2/Serial_Processing.zip">SCRIPT</a><br><br>     -->

<h4>Prepare for playing music: Install Processing 3 Sound Library</h4><br>

Now that we have basic touch input working in Processing, we can connect it to our music play application.<br>
To install the Processing Sound Library, go to <b>Sketch -> Import Library -> Add Library</b>.<br>
Then in the 'Libraries' Tab, search for 'sound' and install the one that is officially from Processing (see image below).<br><br>

<img src="images/lab3/lab2-add-library.png" width="300px"><br><br>
<img src="images/lab3/lab2-add-library-sound.png" width="600px"><br><br>

<h4>Run Skeleton Code</h4><br>

Once you have the library installed, download the <a href="software/music_card_nosolution.zip">skeleton code we provide for you from here</a>.<br>
Inside the folder, open and run the <b>music_card_nosolution.pde</b>, it will take a little while to load until you see the music card image in the view because we also load the mp3 audio files for the songs, which takes some time.<br>
You should see the music card being loaded into your application as shown below. If you don't see it, please let us know.<br><br>
    
<img src="images/lab3/lab2-loadedcard_new.png" width="600px"><br><br>

<h4>Add Touch Buttons onto the Card</h4><br>

Next, we want to mark the three notes as digital touch buttons.<br>
We will use the: <br>
<ul>
  <li>left touch button for previous song</li>
  <li>middle touch button for play/pause</li>
  <li>right touch button for next song</li>
</ul>

<br>

To make this easier for you, we already implemented a class 'Buttons' for you.<br>
You can make a new button with:<br><br>

<pre><span style="red">myButtons.add(new Button(x_top_left, y_top_left, x_bottom_right, y_bottom_right, drawing-mode));</span></pre>

Please add your buttons to line 49 onwards.<br>
One of the buttons is already defined there:<br><br>

<pre>myButtons.add(new Button(360, 180, 440, 260, "Ellipse")); //line 49</pre><br>
    
Your final result should look like this:<br><br>
    
<img src="images/lab3/card_buttons_new.png" width="350px"><br clear=all><br>

<h4>Create Touch Events for Playing / Pausing the Music and Next/Previous Song</h4><br>

To create events on mouse click, we need to implement several mousePressed() events.<br>
We already did this for you in the code further down in the class.<br><br>

<img src="images/lab3/lab2-button-presses.png" width="600px"><br clear=all><br>

We first iterate over all the buttons you created and then depending on the button ID, we want to execute a music function.<br>
We created a music class that loads several example songs in your project folder and has the functions:<br><br>
<pre>music.play();
music.pause();
music.back();
music.forward();
</pre><br>

You can see in the switch/case code that we already assigned the middle button to play and pause music.<br><br>

Extend the code to also go to the next and previous songs.<br>
Click onto the virtual touch buttons, i.e. onto each note, to see if your code works.<br><br>

<h4>Hide the Touch Buttons</h4><br>

While we want to have a touch button on each note, we don't want to see the white ellipses since they make the card look less good.<br>
We already prepared a piece of code for this for you:<br>
Press the 'h' key on your keyboard while your program runs.<br>
It will hide the buttons but you can still click on them.<br>
If you want to see them again, press 's' (for show).<br>
Study the code to see where this was implemented and how we did it.<br><br>

<h4>Now let's play some music from the Inkjet Printed Physical Card</h4><br>

Now that we have the user interface that we can control digitally and we tested that everything works by clicking onto each note to play/pause and go to previous/next song, we also want to play some music from the physical card.<br><br>

You already implemented the Serial communication and the message decoding in the previous exercise, i.e. the Processing application you wrote for displaying the touch bars that go up and down. <br>
Add this code to the music card UI and instead of increasing the height of your bar you are now calling the music functions. <br><br>

Once you have finished the code, try if it works by touching the notes of your printed music card to play/pause the song and go to the next/previous song.<br><br>

<h2 class="headline">Deliverables Lab 2 (due Friday, Sept. 11, 2020, 11.59pm)</h2>

At the end of Lab 3, upload to your student google drive:
<ul>
  <li>the Processing code (.pde) you wrote for Serial communication that displays the three touch bars and the slider bar</li>
  <li>the Processing code (.pde) of the completed music card application</li>
</ul><br>





        <br />
        <br />
        <br />
      </section>

    
     <aside class="col-md-4 pull-left">
         <br /> <br /> <br /> <br /><br>

                 <h4 class="medium.headline" style="padding-bottom:10px;"><a href="6810-engineering-interactive-technologies.html"><b>Lab Series: Inkjet Printed Music Card</b></a><br></h4>

<ul>
    <li><a href="lab1-circuit-design-for-inkjet-printing.html">Lab 1: Circuit Drawings for Conductive Inkjet Printing</a></li>
    <li><a href="lab2-sensing-touch-button.html">Lab 2: Sensing Touch from Inkjet Printed Circuit</a></li>
    <li><a href="lab3-sending-touch-data-to-processing.html">Lab 3: Sending Touch Data to Processing</a></li>
    <li><a href="lab4-touch-slider-extension.html">Lab 4: Sensing Input from a Touch Slider</a></li>
</ul><br>


<iframe width="280" height="158" src="https://www.youtube.com/embed/R7qxT6_8TE4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><br><br>

In this lab series, you will create an interactive music card. Underneath the visual design, the music card has an inkjet printed circuit with touch buttons and a slider that allow the user to play songs and control the volume. The card is connected to a microcontroller for analyzing user input and then sends the signals to a program called Processing for visualizing user input on screen.<br><br>


</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>

      </aside>

    </div>
  </div>
  </div>
</section>

<div class="container">
	<div class="row">
		<div class="col-md-12 footer" style="text-align: center;">
			<span class="copyright">
			Since 2017 &copy; MIT CSAIL (HCI Engineering group) [redesign by
			<a href="http://punpongsanon.info/" target="_blank" style="text-decoration:none; border-bottom:0px">
			moji
			</a>].
			All Rights Reserved.

			<a href="http://mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/mit.svg" alt="MIT" class="footer-logo" />
			</a>
			<a href="http://csail.mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/csail.svg" alt="CSAIL" class="footer-logo"/>
			</a>
			<a href="http://hci.csail.mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="../../images/logo/hci.svg" alt="HCI" class="footer-logo"/>
			</a>
			</span>
		</div>
	</div>
</div>

<!-- Bootstrap -->
<script type="text/javascript" src="../../js/bootstrap.min.js"></script>
<!-- header -->
<script type="text/javascript" src="../../js/headerstrap-for-subpage.js"></script>

</body>
</html>
