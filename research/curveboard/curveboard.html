<!DOCTYPE html>
<html>
<head>
	<title>CurveBoards: Integrating Breadboards into Physical Objects to Prototype Function in the Context of Form</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

	<!-- CSAIL ICON -->
	<link rel="CSAIL" href="http://hcie.csail.mit.edu/images/icon/csail.ico" type="image/x-icon" />

	<!-- Bootstrap -->
	<link href="https://hcie.csail.mit.edu/css/bootstrap.css" rel="stylesheet">
	<link href="https://hcie.csail.mit.edu/css/custom-style.css" rel="stylesheet">
	<!-- Lightbox -->
	<link href="../../css/lightbox.css" rel="stylesheet">


	<!-- jQuery -->
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

	<!-- Google Fonts -->
	<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Abel" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Barlow" rel="stylesheet">

	<!-- Google Analytic -->
	<script type="text/javascript" src="https://hcie.csail.mit.edu/js/analytics.js"></script>
</head>

<body>
<header class="main_header">
	<!-- to be filled by javascript, see header.html -->
</header>
<div class="container" style="padding-top: 100px;">
	<div class="row">
	<!-- Publication details -->
	<div class="col-md-4" style="text-align: left;">
		</br>
		</br>
		<span class="medium-headline">
		Publication
		</span>
		</br>
		</br>
		 Junyi Zhu, Lotta-Gili Blumberg, Yunyi Zhu, Martin Nisser, Ethan Levi Carlson, Xin Wen, Kevin Shum, Jessica Ayeley Quaye, Stefanie Mueller.
		</br>
		 CurveBoards: Integrating Breadboards into Physical Objects to Prototype Function in the Context of Form
		</br>
		In Proceedings of
		<a href="https://chi2020.acm.org" target="_blank">CHI &#8217;20</a>.
			</br>
				<a href="https://doi.org/10.1145/3313831.3376617" class="btn btn-doi" alt="doi" target="_blank">DOI</a>
				&nbsp; &nbsp;
				<a href="http://groups.csail.mit.edu/hcie/files/research-projects/curveboard/2020-CHI-curveboard-paper.pdf" class="btn btn-pdf" alt="pdf" target="_blank">PDF</a>
				&nbsp; &nbsp;
				<!-- link needed -->
				<!-- <a href="https://www.youtube.com/" class="btn btn-vdo" alt="video" target="_blank">Video</a>
				&nbsp; &nbsp;
				<a href="http://groups.csail.mit.edu/hcie/files/research-projects/sequential-support/2019-TEI-Sequential-Support-presentation.pptx" class="btn btn-talk" alt="slide" target="_blank">Slides</a> -->
				&nbsp; &nbsp;
			</br>
			</br>

			<span class="medium-headline">
			Video
			</span>
			</br>
			</br>
			<!-- <iframe width="325" height="190" src="https://www.youtube.com/embed/T-22KOGFLoQ" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe> -->
			</br>
			</br>
			</br>

			<span class="medium-headline">
						Slides
						</span>
						</br>
						</br>
						<img src="http://groups.csail.mit.edu/hcie/files/research-projects/sequential-support/presentation-images/thumbnails/2019-TEI-Sequential-Support-presentation-Slide1_180.jpg" alt="SequentialSupport" width="100px" style="padding-bottom:0px; margin-bottom:10px" onclick="openModal();currentSlide(1)" class="hover-shadow"/>
						


				</div>


				<!-- For slide show -->
					<!-- close button on tne right corner -->

					<div id="lightbox-modal" class="lb-modal">
						<div class="modal-content">
							<div class="lb-slides">
							<div class="numbertext">1 / 92</div>
							<img src="http://groups.csail.mit.edu/hcie/files/research-projects/sequential-support/presentation-images/2019-TEI-Sequential-Support-presentation-Slide1_720.jpg" alt="SequentialSupport" style="padding-bottom:0px; margin-bottom:10px; width:100%">
							</div>

							<div class="lb-slides">
							<div class="numbertext">2 / 92</div>
							<img src="http://groups.csail.mit.edu/hcie/files/research-projects/sequential-support/presentation-images/2019-TEI-Sequential-Support-presentation-Slide2_720.jpg" alt="SequentialSupport" style="padding-bottom:0px; margin-bottom:10px; width:100%">
							</div>

							
							<!-- Next/previous controls -->

			<a class="close-button" onclick="closeModal()">&times;</a>
			<a class="prev" onclick="plusSlides(-1)">&#10094;</a>
			<a class="next" onclick="plusSlides(1)">&#10095;</a>
		</div>
	</div>





	<!-- Project information -->
	<div class="col-md-8" style="text-align: left;">
		<br>
		<h3 class="headline">
		CurveBoards: Integrating Breadboards into Physical Objects to Prototype Function in the Context of Form
		</h3>
		<br>
		<img src="images/Fig 1_0107_v2.png" alt="mosculpt-runner" width="720" style="padding-bottom:0px; margin-bottom:10px"/>
		<br>
		<b>
		Figure 1. (a) CurveBoards are 3D breadboards directly integrated into the surface of physical objects. (b) CurveBoards offer both the high circuit fluidity of breadboards, while maintaining the look and feel of prototypes.
		</b>
		<br>
		<br>
		CurveBoards are breadboards integrated into physical objects. In contrast to traditional breadboards, CurveBoards better preserve the object’s look and feel while maintaining high circuit fluidity, which enables designers to exchange and reposition components during design iteration.
		<br>
		<br>
		Since CurveBoards are fully functional, i.e., the screens are displaying content and the buttons take user input, designers can test interactive scenarios and log interaction data on the physical prototype while still being able to make changes to the component layout and circuit design as needed.
		<br>
		<br>
		We present an interactive editor that enables users to convert 3D models into CurveBoards and discuss our fabrication technique for making CurveBoard prototypes. We also provide a technical evaluation of CurveBoard’s conductivity and durability and summarize informal user feedback.
		<br>
		<br>
		<span class="medium-headline">
		Introduction
		</span>
		<br>
		<br>
		Breadboards are widely used in early-stage circuit prototyping since they enable users to rapidly try out different components and to change the connections between them [23].
		<br>
		<br>
		While breadboards offer great support for circuit construction, they are difficult to use when circuits have to be tested on a physical prototype. Since breadboards are box-like shapes, they distort the look and feel of the prototype when attached onto it and can interfere with user interaction during testing. In addition, they limit where electronic components can be placed on the prototype since the area for circuit construction is limited to the size of the breadboard.
		<br>
		<br>
		One workflow to better preserve the look and feel of the prototype is to solder components onto a protoboard or to fabricate a PCB. However, this requires designers to give up circuit fluidity since all components are fixed in place. Trying out different components and changing connections between them can no longer be done without additional soldering. Alternative methods, such as taping the components onto the prototype, offer more flexibility; however, they make it difficult for designers to exchange and rewire parts and do not offer the same circuit building support as breadboards.
		<br>
		<br>
		In this paper, we present a new electronic prototyping technique called CurveBoard that embeds the structure of abreadboard into the surface of a physical prototype (Figure 1). In contrast to traditional breadboards, CurveBoards better preserve the object’s look and feel while maintaining high circuit fluidity, which enables designers to exchange and reposition components during design iteration.
		<br>
		<br>
		Since CurveBoards are fully functional, i.e., the screens are displaying content and the buttons take user input, designers can user test interactive scenarios and log interaction data on the physical prototype while still being able to make changes to the component layout and circuit design as needed.
		<br>
		<br>
		CurveBoards are not thought to replace existing techniques, such as breadboards or PCBs, but rather provide an additional prototyping technique for early stage interactive device experimentation. CurveBoards work particularly well during mid-fidelity prototyping when designers have already tested basic electronic functionality and in a next step want to work on the interaction design, i.e. integrate electronic parts within the context of a prototype form as part of interactive design practice [26].
		<br>
		<br>
		In summary, we contribute:

		<ul>
			<li> a new electronic prototyping technique for early stage interactive device experimentation called CurveBoard </li>
			
			<li>a demonstration of its applicability across different application scenarios & object geometries at the example of five interactive prototypes </li>

			<li>an interactive editor for converting 3D models into CurveBoards including different options for the channel layout </li>

			<li>a fabrication method for CurveBoards that uses 3D printing for the housing and conductive silicone for channels </li>
			
			<li>a technical evaluation of conductivity & durability </li>
			
			<li>an informal user evaluation with six users who used CurveBoard to build interactive prototypes </li>
			
			<li>an algorithm for automatic pinhole and channel generation given the specific curvature of a 3D model</li>

			<li>a discussion of extensions of our approach, including the use of CurveBoard templates and flexible electronics </li>
			
		</ul>
		In the remainder of the paper, we will first review the related work on electronic prototyping tools and then discuss each of the contributions listed above in order.
		<br>
		<br>


		<span class="medium-headline">
		CURVEBOARDS
		</span>
		<br>
		<br>
		The main benefit of CurveBoards is that they allow designers to iterate on the interaction design of a prototype directly in the context of its physical shape. Using CurveBoards, designers can quickly exchange and reposition components on the prototype’s surface. Once rewired, the prototype is fully functional, i.e. screens on a CurveBoard display content and buttons take user input.
		<br>
		<br>
		By enabling designers to prototype electronic circuits directly on a physical prototype, CurveBoards are particularly suitable for: (1) finding ergonomic and efficient component layouts, (2) ensuring that the components fit onto the physical prototype, (3) preserving a prototype’s look and feel while iterating on a visual design, (4) preserving an object’s intended function while testing a circuit, and (5) identifying component needs based on the prototype’s form factor.
		<br>
		<br>
		In the next section, we illustrate each of these use cases at the example of prototyping an interactive device.
		<br>
		<br>

		<b><strong>#1 Finding Efficient and Ergonomic Component Layouts</strong></b><br>
		For interactive devices, the placement of I/O components plays an important role in achieving efficient and ergonomic interaction. The design of wearables is particularly challenging since I/O components have to be placed with respect to the user’s body and the way the wearable device is worn.
		<br>
		<br>
		Figure 2 shows this at the example of headphones with built-in speakers and music streaming capabilities, for which we explore the placement and type of menu controls to optimize for user’s arm reach and ability to distinguish controls.
		<br>
		<br>
		Our initial version of the prototype had the volume controls on the side of the user’s dominant hand and the playlist controls on the non-dominant hand. After analyzing the logged interaction data recorded on the micro-controller over the course of a day, we realize that the playlist controls are being used more often than the volume controls. We therefore move the playlist controls to the side of the dominant hand.
		<br>
		<br>
		In addition, users informed us that it was difficult to distinguish between the volume and channel controls since they both used press input with similar button sizes. To avoid wrong user input, we replaced the volume buttons with a dial.
		<br>
		<br>
		<br>
		<img src="images/Fig2 Headphone_0107_v2.png" alt="mosculpt-runner" width="720" style="padding-bottom:0px; margin-bottom:10px"/>
		<br>
		<b>
		Figure 2. Finding efficient and ergonomic I/O layouts for a pair of headphones.
		</b>
		<br>
		<br>
		


		<span class="medium-headline">
		Application Use Cases
		</span>
		</br>
		</br>
		In this section, we will illustrate five applications, in-cluding two continuous and three discrete examples. For each example, we will show the use of our design tool, and report on the fabrication and dissolving time as well as the simulation accuracy.
		</br>
		</br>
		<b>#1 Overnight Scent Release (Continuous)</b></br>
		As mentioned above, we can use dissolvable support capsules to release relaxing scents overnight at pre-defined time steps. For this, we printed three support material spheres and filled them with essential oils (paused the print half way through, filled the capsule, continued the print as described in Printed Optics [28]). We then placed the capsules in a water container on the night stand in our bed room.
		</br>
		<img src="images/fig2-scent-release.png" alt="mosculpt-runner" width="455" style="padding-bottom:0px; margin-bottom:10px"/>
		</br>
		<b>
		Figure 2. This nightstand box releases relaxing scents in a pre-defined sequence: the red scent first, then blue, and finally green. (a) Simulation, and (b) actual release.
		</b>
		</br>
		</br>
		Since each sphere had a different wall thickness (2.5mm, 3mm, 4mm), the scents were released one after another after 86 min, 115 min, and 158 min respective-ly. We had previously explored the timing using Se-quential Support’s simulation tool, which had predicted times of 86 min, 135 min, and 163 min for the red, blue, and green capsules.
		</br>
		</br>
		<b>#2 Animating Shadow Art (Continuous)</b></br>
		By leveraging the timing and sequencing prediction of our support material simulation, we can use dissolving support to create shadow art. Figure 3 shows an exam-ple: Before the support material dissolves, the shadow art shows the initial image, i.e. a figure standing under a sunny sky. Once the shadow art starts dissolving, the sun turns into a cloud, the raindrops become visible, and finally an um-brella appears above the figure. The setup that we used to create this sequence consisted of the 3D printed ob-ject submersed in a water container and a light source mounted above it.
		</br>
		<img src="images/fig3-shadow-art-simulation.png" alt="mosculpt-runner" width="455" style="padding-bottom:0px; margin-bottom:10px"/>
		</br>
		<b>
		Figure 3. (a) Simulation: We time the dissolving sup-port to first convert the sun into a cloud, then show the raindrops, and finally an umbrella. (b) Physical result.
		</b>
		</br>
		</br>
		The dissolution time predicted by the simulation was 428 min vs. 380 min for the actual dissolving; the clouds, rain-drops, and umbrella were mostly dissolved at 1/2, 3/4T and at T, respectively, for both simulation and experiment.
		</br>
		</br>
		<b>#3: Design Iteration Partially Replacing a Part (Discrete)</b></br>
		Rather than reprinting the entire object during prototyp-ing, we can use dissolvable support material for the parts that require iteration. Figure 4 illustrates this using a Kinect handle that has been 3D printed to provide the user with a steadier grip while 3D scanning. We are unsure about the exact curvature and spacing for the grip and thus decide to print the grip part in dissolvable support.
		</br>
		<img src="images/fig4-design-iteration.png" alt="mosculpt-runner" width="455" style="padding-bottom:0px; margin-bottom:10px"/>
		</br>
		<b>
		Figure 4. (a) Splitting the model, (b) testing, (c) dis-solving the top part before fabricating the next version.
		</b>
		</br>
		</br>
		We use Sequential Support’s user interface to split the model into two parts (bottom: red PLA, top: white dis-solvable PVA) using the ‘slicing height’ slider. After printing and testing, we notice that the handle does not allow for a firm grip. We thus place it into hot water (70°C), which dissolves the top part within 1-2 minutes (note that discrete scenarios work with a higher water temperature (70°C vs. 45°C, thus dissolving faster). We return to the 3D editor, modify the 3D model, then ex-port again. To reprint the top portion of the grip, we place the previously printed bottom part onto the build plate (using a custom mount and double sided tape) and print the new part directly on top.
		</br>
		</br>
		Printing the new part took only 1h 41 min vs. 5h 16 min for printing the object from scratch (68% faster), and only took 16g material vs. 54g (71% less material). We test the handle again and now it feels right. We dissolve the top one more time and reprint it in red PLA to pro-duce the final version of the design.
		</br>
		</br>
		<b>#4 Breakage Support: Dissolvable Packaging (Discrete)</b></br>
		To prevent fragile regions from breaking during transport, we use support material to reinforce them. Figure 5 shows an example: We print this phone stand in a FabLab but are afraid it might break as we transport it home. (a) After clicking Sequential Support’s ‘stress analysis’ button, we see that the phone stand is likely going to break in the regions close to the fingers. (b) By dragging the ‘support level’ slider, the regions identified by the stress analysis (FEA) are covered in additional dissolvable material.
		</br>
		<img src="images/fig5-breakage-TEI.png" alt="mosculpt-runner" width="455" style="padding-bottom:0px; margin-bottom:10px"/>
		</br>
		<b>
		Figure 5. (a) Stress map, (b) breakage support. (c) Transporting the object, and (d) after dissolving the support material on arrival use the phone stand.
		</b>
		</br>
		</br>
		Adding the support increased printing time by only 19% (17h51 vs. 15h01) and required only 6g of support add-ed to 107g PLA. After transporting the object home, softening the support using hot water (70°C) took only 4 minutes; we then wiped off the rest by hand and were ready to use the object within 15 minutes.
		</br>
		</br>
		<b>#5 Assembly: Temporary Labels (Discrete)</b></br>
		In our final use case, we use support material to simplify assembly. Here, we design a lamp that consists of 10 different parts. First, we use Sequential Support’s user interface and attach matching labels to the parts of the object that belong together using the ‘label’ buttons (Figure 1c).
		</br>
		</br>
		Next, we create ‘stickers’, i.e., small support structures that can be used to connect two parts together (Figure 6a). These structures work as temporary adhesives to put parts that belong together close to each other (e.g., a nut that belongs to a particular threaded protrusion). Users can break them off during assembly and dissolve the rest later together with the labels (ca. 2-3 min in 70°C).
		</br>
		<img src="images/fig6-attach-TEI.png" alt="mosculpt-runner" width="455" style="padding-bottom:0px; margin-bottom:10px"/>
		</br>
		<b>
		Figure 6. (a) Small support structures can be used as connectors, to hold parts in place for (b) later assem-bly. (c) Mounting the assembled lamp onto the wall.
		</b>
		</br>
		</br>
		<span class="medium-headline">
		Simulation of Dissolving Support Material
		</span>
		</br>
		</br>
		In the next section, we describe the algorithm used in our support material simulation that enables the contin-uous-time application scenarios. Our simulation takes into account different factors involved in dissolving support material, which we primarily base on related research on dissolving crystals in solvents [2, 5, 15].
		</br>
		</br>
		<b>Step #1: Voxelizing the Model</b></br>
		As soon as the user assigns support material (‘PVA’) as a shader to a part of a 3D model, we begin pre-processing the part to enable the simulation. We begin by voxelizing the part: We first compute the part’s bounding box and then fill it with voxels of size N (we use: side length = 0.3mm; the higher the resolution the more accurate the simulation, however, this comes with the trade-off of increased computational complexity that limits interactive exploration in the design inter-face). We then keep all voxels that intersect with the part’s surface and discard the rest.
		</br>
		</br>
		<b>Step #2: Dissolution Probability for Number of Faces</b></br>
		Each remaining voxel can have one of two states: dis-solving in the current time step or not dissolving. To determine the probability that a voxel will dissolve, we use the following equation (initially proposed by Gilmer et al. [5] and extended by Briese et al. [2]):
		</br>
		<img src="images/formula_diss.png" alt="mosculpt-runner" width="60" style="padding-bottom:0px; margin-bottom:1px"/>
		</br>
		As can be seen in the formula, the probability that a voxel dissolves increases exponentially with the num-ber of faces f exposed to the solvent. A voxel that is attached on only one side and thus has 5 faces exposed to the solvent, has a much higher chance of dissolving than a voxel with only one exposed face (Figure 7). This is why support structures on a model’s surface dissolve faster than those in small inlets (e.g., screw holes), and why sparse structures dissolve faster than solids.
		</br>
		<img src="images/fig7-number-of-faces.png" alt="mosculpt-runner" width="455" style="padding-bottom:0px; margin-bottom:10px"/>
		</br>
		<b>
		Figure 7. The more faces of a voxel are exposed to the solvent, the higher the probability that it dissolves.
		</b>
		</br>
		</br>
		In the formula, T is the temperature of the water in Kel-vin (constant at 318K or 45°C), k is Boltzmann’s con-stant (1.38064852 × 10-23 m2kg/s2K), and v and φ are constants that influence the speed of dissolution. We determined v and φ for our setup as described in section ‘Characterizing simulation parameters’ (v = 6.5, φ = 1.9).
		</br>
		</br>
		Inserting all values into the formula, and varying the numbers of faces f from 1-5 gives us the probability for a voxel to dissolve based on its number of faces: f1 = 0.00049, f2 = 0.0032, f3=0.021, f4=0.15, f5=0.97 (Figure 7).
		</br>
		</br>
		<b>Step #3: Drawing a Random Sample</b></br>
		We then use these probabilities as inputs to a kinetic Monte Carlo simulation as described in Briese et al. [2].
		We start by drawing a random number n from a uniform distribution on the interval [0,1]. This number is then compared to the probability that each voxel will dis-solve. If the random number is smaller than the dissolu-tion probability of the voxel, the voxel is dissolved. If not, it stays put.
		</br>
		</br>
		After removing all dissolved voxels in the current time step, new surface voxels are generated to ensure that the voxel layer remains 1 voxel thick. We then repeat step #2 and #3. Figure 9 shows some results from our simulation.
		</br>
		</br>
		<b>Step #4: Rendering</b></br>
		We then convert the voxel model into a continuous surface using the Laplacian smoothing algorithm from the Weaverbird [27] Grasshopper add-on to render a more visually compelling result.
		</br>
		</br>
		<span class="medium-headline">
		Characterizing Simulation Parameters
		</span>
		</br>
		</br>
		Next, we explain how we determine the two input pa-rameters v and φ for the dissolution formula experimentally.
		</br>
		</br>
		<b>Factors v (global dissolve speed) and φ (local speed)</b></br>
		The factor v represents the global dissolve speed inde-pendent of the number of faces. The factor φ, in con-trast, represents the local speed with which each voxel dissolves based on the number of its exposed faces f.
		</br>
		</br>
		For instance, consider the effect of varying v and φ on a ‘star’ shape. If φ is small, the number of faces exposed to the solvent has less of an effect on the probability of dissolution of each voxel. As a result, voxels at the tips of the star (containing more exposed faces) will be dis-solved at rates similar to those voxels composing the flat sides of the star (fewer exposed faces). Therefore, with small φ, the star will remain star-shaped. In con-trast, if φ is large, the number of faces exposed will play a greater role and the tips of the star will dissolve faster than the flat sides of the star, leading the star to become sphere-like.
		</br>
		</br>
		<b>Collecting Test Data</b></br>
		To determine the parameters v and φ, we printed differ-ent shapes (sphere, star, cube). We dissolved them in water and captured images using a front view camera (Figure 8). The shapes measured: cube length: 15mm, sphere diameter: 15mm, and star outside diameter: 24mm.
		</br>
		<img src="images/fig8-physical-dissolve.png" alt="mosculpt-runner" width="455" style="padding-bottom:0px; margin-bottom:10px"/>
		</br>
		<b>
		Figure 8. Dissolving shapes over time.
		</b>
		</br>
		</br>
		We used a 3-liter water tank and heated the water to a temperature of 45°C. This was the highest temperature chosen based on a trade-off between faster dissolution times and a tendency of the solvent to become cloudy at elevated temperatures, preventing us from recording the experiment.
		</br>
		</br>
		We also created a mild current by using a 20mm mag-netic stirrer at 600rpm. The reason we use stirring is that when support material dissolves, the resulting particles stay close to the location where they dissolved, i.e., close to the object’s surface. The more particles are floating close to the surface, the slower the support material dissolves.
		</br>
		</br>
		After immersing the objects in water, we took pictures every 8 minutes (Figure 8). We collected the same data from our simulation, i.e., we ran our simulation with an initial set of parameters for factor v and φ on the three test shapes and took screenshots from the same angle that the physical camera took photos of the real objects (Figure 9).
		</br>
		<img src="images/fig9-simulation-results.png" alt="mosculpt-runner" width="455" style="padding-bottom:0px; margin-bottom:10px"/>
		</br>
		<b>
		Figure 9. Simulation pictures.
		</b>
		</br>
		</br>
		<b>Extracting & Comparing Shape Contours</b></br>
		We used OpenCV to extract and then compare the shape contours. We first thresholded the images and then ex-tracted huMoments to gain a feature vector describing the contours in a translation-, rotation-, and scale-invariant manner. We applied the same procedure to both the photos and the screenshots to gain a feature vector for each.
		</br>
		</br>
		<b>Computing Error and Adjusting Simulation Parameters</b></br>
		We then used the two feature vectors to compute the error (Euclidean distance) between the actual physical behavior and our simulation. This error is thus based on the compared 2D images (photos and simulation screenshots), which we use as a proxy for the difference between the full 3D shapes.
		</br>
		</br>
		We then chose another set of simulation parameters v and φ, re-ran our simulation with the new v and φ and compared the error to the error from the previous pa-rameters (we always first picked φ, and then adjusted the corresponding v (global speed) until the probability for a voxel that has 5 faces (f5) was 97%). The results for each set of φ and v can be seen in Figure 10.
		</br>
		</br>
		We found that φ = 1.9 and v= 6.5 lead to the best results across the three different shapes (lowest average error between the feature vectors over all time steps). Figure 10 summarizes the result for dissolving the same objects (star, sphere, cube) twice. We found that the error be-tween the two experiments differed by less than 10%.
		</br>
		<img src="images/fig10-Euclid_distance_Error_VS_hours.png" alt="mosculpt-runner" width="455" style="padding-bottom:0px; margin-bottom:10px"/>
		</br>
		<b>
		Figure 10. Graph of feature vector errors over time.
		</b>
		</br>
		</br>
		<span class="medium-headline">
		Implementation
		</span>
		</br>
		</br>
		Both the simulation and the use-case specific features in our design tool are implemented as a Grasshopper plugin for the 3D editor Rhino 3D. We used the Hu-manUI library for the user interface elements.
		</br>
		</br>
		<b>Design Iteration: Splitting the Model & Off-Setting It</b></br>
		To split the model in half at the desired height, we use the Grasshopper SplitBrep() function. On export of the .stl files, the two parts are merged into a closed solid using the Grasshopper Cap function. After splitting and capping, the two geometries are baked to a new layer in Rhino using the function GH_Bake(). We use a custom script to export each geometry on the GH_Bake layer as individual .stl files (both are regular closed meshes, i.e. the parts can have sparse infills but will be separated by a solid layer). When printing a new iteration, the system only exports the top geometry as an .stl file. We then run a python script in the background that offsets the gcode com-mands in the Z direction by the height of the PLA part.
		</br>
		</br>
		<b>Stress Analysis using Finite Element Analysis</b></br>
		To create the stress analysis for our model, we use Rhi-no’s Scan&Solve plugin. The plugin comes with a func-tion called AddFaceVectorLoad(), which we give a set of input forces with a uniform load of 100N pointing from the top to the bottom. To display the resulting stress distribution we use the function SolutionDis-playEnable(). We then get the points of the highest stress using the function QuerySolutionValue(), which returns a list of stress values at all points on the model. We sort this list using a custom python script and then create a number of spherical support structures to cover the stress points commensurate with a value chosen using the slider in the user interface.
		</br>
		</br>
		<b>Assembly Instructions</b></br>
		To set up the snap locations on both the object and the instruction labels, we generate ‘point’ objects in Rhino. When the user connects two parts, we call Rhino’s ori-ent() function to snap the instruction label onto the reference point. We use the same approach for the at-tach option.
		</br>
		</br>
		<b>Scent Release and Shadow Art</b></br>
		Both examples use the simulation described previously in section ‘Simulation of Dissolving Support Material’.
		</br>
		</br>
		<span class="medium-headline">
		Limitations
		</span>
		</br>
		</br>
		While our approach enables new application scenarios, it is subject to the following limitations: (1) single-use only: once the support is dissolved, we cannot repeat the functionality. Thus, using support material works best for scenarios that require functionality only once, such as during assembly, product configuration, or transportation. (2) Simulation Precision: Since our set of sample shapes was small and the parameters were only optimized over a narrow range, the simulation should be fine-tuned in future work using additional shapes. (3) Speed: While the process of dissolving is fast at high water temperatures and for small amounts of support (only a few minutes for thicknesses in the vicin-ity of 1mm), it can take hours at low temperatures and when a lot of support material needs to dissolve. Thus, our work is limited to application scenarios with an extended time span, such as the overnight scent release or the slowly changing shadow art piece that could be displayed in a public plaza. (4) Overhangs: The support material cannot be used to print support structures for overhangs if those interfere with the main dissolving geometry. (5) Adherence: Current PVA support material is challenging to print since it does not adhere well to the regular PLA printing material. Printing on large flat surfaces (e.g. as in the design iteration case) facilitates adherence, while more complex geometries, such as the phone stand, are more difficult to print.
		</br>
		</br>
		<span class="medium-headline">
		Discussion
		</span>
		</br>
		</br>
		In this paper, we provided a first exploration into how support material can be used for different application use cases. However, for each individual use case, a more extensive exploration is required to analyze the trade-offs of using support material vs. traditional approaches.
		</br>
		</br>
		For instance, using support material in the design itera-tion use case can accomplish the same function (i.e. replacing a part of the object geometry) as by using a milling machine (see Patching Physical Objects [22]). Compared to using a mill, our approach has the benefit of not requiring additional hardware and being faster when a high temperature bath is used (minutes of dis-solving vs. hours for milling). However, when using a mill, the user can decide which part to replace after printing, whereas in our approach the user needs to decide which part requires iteration before printing. In both processes, alignment and delamination are chal-lenges that need further investigation. In contrast to approaches that use joints to connect parts [7, 20] or rafts / brims, our method does not require modifying the model.
		</br>
		</br>
		Similar trade-offs need to be explored for the other use cases, such as the breakage support. For instance, the benefit of our approach compared to traditional packag-ing is that it reinforces the object locally at its most fragile locations; this is different from packaging foam, which provides aggregate protection across the entire object. In addition, our approach provides additional breakage support even after being removed from the main packaging and during handling, until dissolved by the end user. On the other hand, if the amount of protec-tive support is large and requires a long time to print, the high speed of traditional wrapping techniques might outweigh the advantage of local support. Finally, de-pending on the circumstances, the soluble support pack-aging may need to be protected against humidity as this could weaken the structure over time.
		</br>
		</br>
		<span class="medium-headline">
		Conclusion
		</span>
		</br>
		</br>
		We presented Sequential Support, a system that enables users to use support material in 3D printing as a feature and not as a time- and material-consuming necessity. We showed how Sequential Support allows users to create a variety of objects for different application sce-narios, such as dissolvable prototype parts, breakage support, assembly labels, and time- and sequence-dependent shadow art and scent release mechanisms. For future work, we plan to run a qualitative study in which we will investigate how our method changes par-ticipants’ design practices. We will also use this study to explore additional application scenarios with partici-pants. In particular, we are interested to further explore use cases in fabrication in which objects have a limited life-span such as those outlined in Mobile Fabrica-tion [19], which include temporary tools and short-term fixes to everyday objects.
		</br>
		</br>
		<span class="medium-headline">
		Acknowledgements
		</span>
		</br>
		</br>
		We thank Dishita G. Turakhia and Yini Qi for their help with video editing.







		</br>
		</br>
		</br>
		</br>
		</br>
		</br>
		</br>
		</br>
		</br>
		</br>


	</div>
	</div>
</div>

<div class="container">
	<div class="row">
		<div class="col-md-12 footer" style="text-align: center;">
			<span class="copyright">
			Since 2017 &copy; MIT CSAIL (HCI Engineering group) [redesign by
			<a href="http://punpongsanon.info/" target="_blank" style="text-decoration:none; border-bottom:0px">
			moji
			</a>].
			All Rights Reserved.

			<a href="http://mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="http://hcie.csail.mit.edu/images/logo/mit.svg" alt="MIT" class="footer-logo" />
			</a>
			<a href="http://csail.mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="http://hcie.csail.mit.edu/images/logo/csail.svg" alt="CSAIL" class="footer-logo"/>
			</a>
			<a href="http://hci.csail.mit.edu/" target="_blank" style="text-decoration:none; border-bottom:0px">
			<img src="http://hcie.csail.mit.edu/images/logo/hci.svg" alt="HCI" class="footer-logo"/>
			</a>
			</span>
		</div>
	</div>
</div>

<!-- Bootstrap -->
<script type="text/javascript" src="https://hcie.csail.mit.edu/js/bootstrap.min.js"></script>
<!-- header -->
<script type="text/javascript" src="https://hcie.csail.mit.edu/js/headerstrap-for-subpage.js"></script>
<!-- lightbox -->
<script type="text/javascript" src="../../js/lightbox.js"></script>

</body>
</html>
